
유니티 그래픽스 최적화

최적화 필요성
최적화를 신경 쓰지 않고 유저들이 불쾌함을 느끼는 경우가 생김
화면이 버벅이며 끊기는 느낌,부드럽지않게 갱신,입력 딜레이 등

최적화 시기
개발 초반부 기간을 제외한 모든 개발 기간동안 항상 신경써야함

보통 그래픽 쪽에 부하가 많이 걸리며 코드 잘못짜도 렉이 걸리긴 하다

////////////////////////////////////////////////////////////////////////

누구의 책임인가
프로그래머와 아티스트 모두 신경써야 하는 부분,
그래픽 요소의 최적화는 아티스트 의존성이 크다.

최적화 작업이 필요한 이유
게임이 리얼타임(real time), 실시간으로 렌더링이 이루어지기 때문

//////////////////////////////////////////////////////////////////////////////////////

렌더링
컴퓨터가 주어진 데이터(게임오브젝트, 위치값, 쉐이더, 카메라가 촬영하는 화면 등)
를 기반으로 이미지를 만들어 내는 과정

하나의 장면에 대하여 도형들의 배치에 대한 정보, 텍스처, 라이팅, 쉐이딩 등 정보를 중ㅁ
그래픽 처리 전용 프로세서의 GPU 가 그래픽 파이프 라인을 거쳐 이미지를 만들어냄

영화, 애니메이션, 화면 디스플레이, 웹 브라우저 의 글자나 이미지 출력 등

//////////////////////////////////////////////////////////////////////////////////////////////////

비실시간 렌더링 (non-realtime)
영화나 애니메이션은 정해진 장면을 모두 미리 렌더링
렌더링한 이미지를 프레임별로 나열해 동영상을 만듦
고품질의 그래픽을 만들기 위해 비싼 연산과 많은 렌더링시간을 투자

 실시간 렌더링(realtime)
-게임의 렌더링은 사용자의 반응과 입력에 따라 달라짐
-씬의 렌더링을 매우 빠른 속도로 수행하는 것이 중요

///////////////////////////////////////////////////////////////////////////////////////////////////////////

 FPS(Frames per second)
-렌더링 속도 측정 기준 단위
-초당 몇 프레임을 렌더링 하는가
 영화나 애니메이션은 24FPS 에 불과하고, 게임은 40~60FPS 목표치를 삼는다.

 모바일 디바이스 의 성능
-데스크톱과 다르게 모바일 기기는 항상 전원이 연결되어 있는 상황이
 아니므로 전력소모에 맞추어 만듦 (+발열)

//////////////////////////////////////////////////////////////////////////////////////////////

 쓰로틀링(Throttling)
-기기의 발열이 심해져서 온도가 일정 이상 높아지면 발열을 낮추기 위해 자동으로
 기기 성능을 낮추는 기능
-쓰로틀링 상태로 진입하면 기기의 연산속도가 느려저 FPS 가 떨어지므로
 쓰로틀링 상태가 되지 않도록 최적화 시키는 것이 중요

////////////////////////////////////////////////////////////////////////////////////////////////

 엔진과 그래픽스 API
- 유니티는 멀티플랫폼 엔진으로 다양한 그래픽 칩셋에서 렌더링이 지원됨
- 다양한 종류의 GPU 들은 각각의 펌웨어 및 드라이버를 제공하고,
  각각의 GPU 및 OS 별로 따로 신경 쓰지 않고 렌더링 소프트웨어(Maya, 3dsMax)
  를 만들 수 있도록 그래픽스 API(DirectX, OpenGL)가 제공
- 하지만 그래픽 API도 OS 에 따라 다양하게 존재함
- 유니티는 알아서 각 플래폼에 맞는 그래픽 API 로 렌더링 해줌

//////////////////////////////////////////////////////////////////////////////////////////////////

 OpenGL & OpenGL ES
- OpenGL    : 컴퓨터 그래픽스 의 표준 규격을 기준을 기반으로 발표한
              2D,3D 그래픽스 표준 API
- OpenGL ES : OpenGL 을 그래도 모바일 시스템에서 구동시키기엔 무리,
              크로노스 그룹은 모바일 환경에서의 2D,3D 그래픽스를 위해
			  더 가벼운 OpenGL ES 제정
- ES 는 Embedded System 으로 OpenGL 에서 잘 사용되지않는 것을 축소하여
  만든 서브셋
  
  Metal
- 애플이 만든 IOS 전용 그래픽스 API
- 대부분의 모바일 장치에서 사용 가능한 OpenGL 은 불필요한 오버헤드 가 발생했지만
  Metal 은 IOS 만 지원함으로 오버헤드 를 줄여 성능을 향상시킴
- 여러 연산을 동시에 병력적으로 진행할 수 있는 멀티쓰레딩에 대응 가능
- CPU 와 GPU 메모리 영역이 구분된 OpenGL 과 달리 Metal 은 구분없이
  메모리를 사용해 효율적으로 관리 가능
  
  Vulkan
- 크로노스 그룹이 만든 차세대 API
- 멀티쓰레드 화 가능으로 CPU 오버헤드 감소

 유니티 설정
Edit > Project Settings > Player > Android Setting
> Other Settings > Rendering > AutoGraphics API 체크 해제

////////////////////////////////////////////////////////////////////////////////////////////////

렌더링 파이프 라인

GPU 의 의미

 랜더링 파이프 라인
- 3D 이미지를 2D 래스터 이미지로 표현하기 위한 단계적인 방법

 그래픽 처리 장치 (Graphics Processing Unit)
- CPU 가 GPU 에 렌더링 명령을 보내고, GPU 는 GPU 메모리(VRAM)를 참고해
  그래픽 처리를 수행
- 모바일 기기에서는 하나의 물리적 RAM에 CPU 메모리와 GPU 메모리 를
  나누어 사용하기도 함
  
/////////////////////////////////////////////////////////////////////////////////////////////

 게임 실행시 초기화 과정을 거치며 필요한 리소스 만듦(Initialization)
- Awake, OnEnable, Start 등

 게임수행시 매 프레임 마다 뎅터 업데이트 후 렌더링
- Update : Physic, Input Events, Game logic 등
- Render : Scene renderingm GUI rendering 등

 게임 종료시 리소스 들이 해제 (Decommissioning)

////////////////////////////////////////////////////////////////////////////////////////////////

 렌더링 루프
- Update 과정은 주로 CPU 에서 이루어지는 연산

- Rendering 과정에서는 렌더링이 진행되며, 순차적으로 그려짐
- 빈 화면 > 캐릭터 > 발판 > 배경...

////////////////////////////////////////////////////////////////////////

 렌더링 파이프 라인 (Rendering Pipeline)
- 3D 오브젝트를 2D 이미지 상으로 그리는 과정
- 애플리케이션 -> 지오메트리 -> 래스터라이저

/////////////////////////////////////////////////////////////////////////////////////////////////

 1. 애플리케이션 스테이지(Update문 이라고 생각하면 편함)
- 렌더링 되기 전 업데이트 및 기타 데이터 처리과정
- 주로 CPU 에서 필요한 연산 처리
- 캐릭터가 이동할 때 - 매 프레임 마다 애니메이션 정보와 뼈대
  위치 연산 밒 메시의 버텍스에 반영

////////////////////////////////////////////////////////////////////////////////////////////////

 2. 지오메트리 스테이지
- 지오메트리를 구성하는 버텍스와 폴릭곤의 처리
- 오브젝트의 각 버텍스틀을 화면상의 적절한 위체에 배치시키는 과정
- 메시(Mesh)
  오브젝트의 형태를 보여줌(그려낸 것 까지)
  Verices(점) > Edges(선) > Polgons(Polys)(면) > 메쉬
  
- 버텍스 트랜스폼(Vertex Transform)
  (1) 월드 트렌스폼 : 원점 기준(0,0,0) 의 메시 모델에 대한 위치데이터만 가지고 있는
                로컬 스페이스를 3D 공가낭의 특정 위치인 월드 스페이스로 변환

  (2) 뷰 트랜스폼 : 오브젝트를 카메라에 상대적인 위치로 변환하기 위해 월드 스페이스를 카메라(뷰)로 전환

  (3) 프로젝션 트렌스폼 : 3D 공간을 2D 상의 위치로 매칭하는 과정

원근투영(Perspective Projection) : 원근법이 적용된 프로젝션 트랜스폼
직교투영 (Orthographic Projection) : 원근법 미적용
  

- 버텍스 쉐이더 (Vertex Shader)
  버텍스 별로 값을 설정하는 과정
- (1) 월드-뷰-프로젝션 트랜스폼 변환 : 메시의 버텍스를 적절한 위치에 있도록
                                  버텍스에 행렬을 곱해줌으로 써 수행

- (2) 왜곡 : 특수한 효과를 위해 버텍스의 노멀 방향으로의 확장 등

- (3) 노멀 및 걸러 결정 : 라이팅이 픽셀별이 아닌 버텍스 별로 처리 된다면
                        버텍스 쉐이더에서 라이팅 처리가 되고,
					    버텍스컬러에 라이팅 결과 반영



 지오메트리(Geometry) 생성
- 버텍스 쉐이더를 거치고 나면 버텍스들이 연결되어 선이 만들어지고 도형의 형태가 됨.
  이러한 도형의 형태를 지오메트리 라고함

- 버텍스 쉐이더 에서 트랜스폼이 결정되고 나면 자동으로 이루어지는 과정

- 파이프라인에 입력받은 버텍스들은 모두 지오메트리화
  (화면 밖에 렌더링 되지 않는 버텍스 들도 적용)

- 그만큼 버텍스가 많으면 지오메트리 스테이지에서 병목이 발생할 확률이 높음
  -> 카메라 영역 밖에 있는 오브젝트들은 파이프 라인을 거치지 않도록 하는
	 컬링 기법 등이 있음

////////////////////////////////////////////////////////////////////////////////////////////////  
  
 3. 레스터라이저 스테이지
- 오브젝트를 그리는 픽셀을 추리고 그 픽셀의 색을 결정하는 과정
- 메시의 폴리곤에 속한 영역을 픽셀로 매칭 시키는 과정

 뎁스 버퍼, z버퍼
 - 픽셀의 색상 정보는 컬러버퍼의 R,G,B a 4가지 채널에 저장되는 것처럼
   픽셀의 깊이값을 저장하는 버퍼(Z버퍼는 컬러버퍼와 동일한 해상도)
 
 - 화면에 가까운 위치에 있는 오브젝트가 먼저 그려지고 뒤에 가려지는 오브젝트가 그려짐
   단점으로 처음 오브젝트가 반투명이면 뒤에 오브젝트 색상에 연산을 그만큼 더함
   
 - 픽셀의 깊이값은 카메라로부터의 거리 이며 Z버퍼를 이용해
   픽셀이 렌더링 될 때마다 깊이 판정을 수행

 프래그먼트/픽셀 쉐이더(Fragment/Pixel Shader)
- Fragment : 화면상에 최종 Pixel이 되기전 의 데이터 (픽셀이라 해도 무방)
- 픽셀들의 최종 렌더링 색을 계산하기 위해 텍스처로부터 색을 읽어오고
  그림자를 적용하는 등의 일을 처리

 알파 블렌딩(Blending)
- 투명도를 가지는 오브젝트가 거치는 과정으로 쉐이더에서 결정되는
  알파값과 해당 픽셀 위치의 컬러 버퍼의 값을 적절히 혼합하여 최종 출력 색생 결정

//////////////////////////////////////////////////////////////////////////////////////////////////////////

정리

모든 오브젝트가 렌더링 될 때마다 이러한 과정을 거치며 버퍼에 차곡차곡 그려짐
 
 더블 버퍼링
- 두개의 버퍼를 번갈아 가면서 렌더딩한 후 화면에 보여주는것
- 화면에 보이고 있는 버퍼는 프론트 버퍼, 렌더링 되는 버퍼는 백버퍼

 렌더 루프
 Update -> Cull(카메라에 보이지 않는부분 을 필터링 함)
 -> Scene Render(작업이 끝나면 2D에 보이는 이미지 작업이 끝남)
 -> PostProcessing
 
 1. 업데이트 : 렌더링 전 연산
 2. 컬링     : 불필요한 렌더링 부하를 방지하기 위한 컬링 연산
 3. 씬 렌더링 : 오브젝트마다 드로우콜 이 발생하며 버텍스/프래그먼트 쉐이터, Z테스트,
               알파 블랜딩 등의 GPU 파이프 라인을 거쳐 버퍼에 순차적으로 렌더링
			   (부하 제일 심함)
 4. 포스트 프로세싱(후처리) : 블룸이나 컬러 그레이딩 등의 포스트 프로세싱 처리.
                           한번 이상의 드로우 콜이 발생
 5. 디스플레이(더블 버퍼링) : 현재 프레임이 렌더링 되고 있는 백버퍼는 프론트 버퍼로 교체되어 화면에 나타나고,
                           기존의 프론트버퍼는 다음 프레임 렌더링을 위해 백버퍼가 됨
						   (부하 많이 안먹음)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
