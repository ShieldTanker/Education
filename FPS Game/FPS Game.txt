
프로토 타입 단계 부터 시작

씬 이름 변경 > MainScene

바닥 추가
3D 오브젝트 Plane 추가 > Ground 로 이름 변경
스케일 10, 1, 10

프로젝트뷰 Materials 폴더 추가 > 마테리얼 생성 Mat_Ground 로 변경 색 지정
Ground 에 넣기

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Capsule 오브젝트 추가 > Player 로 변경
위치값 0, 1, 0

MainCamera 오브젝트에 CamRotate 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamRotate : MonoBehaviour
{
    // 회전 속도 변수
    public float rotSpeed = 200f;

    float mX = 0f;
    float mY = 0f;

    private void Update()
    {
        // 마우스 입력을 받음
        float mouse_X = Input.GetAxis("Mouse X");
        float mouse_Y = Input.GetAxis("Mouse Y");

        // 회전값 변수에 마우스 입력값만큼 미리 누적
        mX += mouse_X * rotSpeed * Time.deltaTime;
        mY += mouse_Y * rotSpeed * Time.deltaTime;

        // 마우스 상하 이동 회전 변수(mY) 의 값을 -90 ~ 90 도 사이로 제한
        mY = Mathf.Clamp(mY, -90, 90);

        // 마우스 입력 값을 이용해 외전 방향을 결정(X축기준 회전 : 상하, Y축 기준 회전: 좌우)
        // 회전 방향으로 오브젝트 회전
        transform.eulerAngles = new Vector3(-mY, mX, 0);
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 회전 구현

Player 오브젝트에 PlayerRotate 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerRotate : MonoBehaviour
{
    // 회전 속도 변수
    public float rotSpeed = 200f;

    // 회전값 변수
    float mx = 0f;

    private void Update()
    {
        // 마우스 좌우 입력을 받음
        float mouse_X = Input.GetAxis("Mouse X");

        // 회전 값 변수에 마우스 입력 값만큼 미리 누적
        mx += mouse_X * rotSpeed * Time.deltaTime;

        // 회전 방향으로 물체를 회전기킴
        transform.eulerAngles = new Vector3(0, mx, 0);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

카메라 위치를 플레이어 와 동기화

Player 오브젝트에 자식 오브젝트로 빈오브젝트 CamPosition 생성
위치값 0, 0.25, 0

MainCamera 오브젝트에 CamFollow 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamFollow : MonoBehaviour
{
    // 목표가 될 트랜스폼 컴포넌트
    public Transform target;

    private void Update()
    {
        // 카메아의 위치를 목표 트랜스폼의 위치에 일치시킴
        transform.position = target.position;
    }
}

target 에 CamPosition 참조 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 움직임 구현

Player 오브젝트에 PlayerMove 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMove : MonoBehaviour
{
    public float moveSpeed = 7f;

    private void Update()
    {
        // 사용자의 입력을 받음
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        dir = dir.normalized;

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);

        // 이동 속도에 맞춰 이동
        transform.position += dir * moveSpeed * Time.deltaTime;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

중력 적용

위를 바라볼시 공중에 뜨는 문제 해결하기위해 중력 만들기

Player 오브젝트 선택 Character Controller 컴포넌트 추가

Character Controller 에는 이미 Collider 가 있기 때문에 
기존에 있던 Collider 컴포넌트 는 제거

PlayerMove 스크립트 열기

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMove : MonoBehaviour
{
    // 이동 속도 변수
    public float moveSpeed = 7f;

    // 캐릭터 컨트롤러 변수
    CharacterController cc;

    // 중력 변수
    float gravity = -20f;

    // 수직 속도 변수
    [SerializeField]
    float yVelocity = 0f;

    // 점프력 변수
    public float jumpPower = 10f;

    // 점프 상태 변수
    public bool isJumping = false;

    private void Start()
    {
        cc = GetComponent<CharacterController>();
    }

    private void Update()
    {
        // 사용자의 입력을 받음
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        dir = dir.normalized;

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);

        // 점프 후 바닥에 닿은 상태인지 확인
        if (isJumping && cc.collisionFlags == CollisionFlags.Below)
        {
            // 점프 가능하게 변경
            isJumping = false;

            // 캐릭터의 수직속도를 0으로 만듬
            yVelocity = 0f;
        }

        // 만약 Spacebar 키를 입력했으면
        if (Input.GetButtonDown("Jump") && !isJumping)
        {
            // 캐릭터 수직 속도에 점프력 적용
            yVelocity = jumpPower;
            isJumping = true;
        }

        /* 이동 속도에 맞춰 이동 (캐릭터 컨트롤러로 이동함)
        transform.position += dir * moveSpeed * Time.deltaTime; */

        // 캐릭터 수직 속도에 중력 값을 적용
        yVelocity += gravity * Time.deltaTime;
        dir.y = yVelocity;

        // 이동속도에 맞춰 이동
        cc.Move(dir * moveSpeed * Time.deltaTime);
    }
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

수류탄 구현

3D 오브젝트 Sphere > Bomb 으로 변경 > 위치값 초기화

RigidBody 컴포넌트 추가

BombAction 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BombAction : MonoBehaviour
{
    public GameObject bombEffect;


    // 충돌시 처리
    private void OnCollisionEnter(Collision collision)
    {
        // 이펙트 프리팹 생성
        GameObject eff = Instantiate(bombEffect);

        // 이펙트의 위치는 자기 자신과 동일
        eff.transform.position = transform.position;

        // 자기자신 제거
        Destroy(gameObject);
    }
}

Bomb 을 프리팹으로 저장

/////////////////////////////////////////////////////////////////////////////////

에셋다운
에셋의 스크립트 폴더 제거

Exploson1 프리팹 의 스크립트 들 제거, 
자식오브젝트 의 Explosion - [Explosion6] 에 Simulation Speed 값을 2로 설정

프리팹의 부모 오브젝트에 DestroyEffect 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DestroyEffect : MonoBehaviour
{
    // 제거될 시간 변수
    public float destroyTime = 1.5f;

    //경과 시간 측정용 변수
    float currentTime = 0;

    private void Update()
    {
        // 만일 경과 시간이 제거될 시간을 초과하면 자기 자신을 제거
        if (currentTime > destroyTime)
        {
            Destroy(gameObject);
        }
        // 경과시간 누적
        currentTime += Time.deltaTime;
    }
}


위 코드 말고 Start() 에 Destroy(gameObject,1.5f); 해도 똑같음

////////////////////////////////////////////////////////////////////////////////////////////////////

Exploson1 프리팹 저장 후 오브젝트 로 끌어온 뒤 FX_Bomb 으로 이름 변경
자주 사용할 프리팹 폴더를 따로 만들고 그곳에 오리지날 프리팹으로 FX_Bomb 저장

///////////////////////////////////////////////////////////////////////////////////////////////////

BombAction 의 Bomb Effect 칸에 FX_Bomb 을 참조 연결

수류탄이 플레이어 와 닿아도 터지는 문제 를 없애기 위해 Layer 를 추가
각각 오브젝트에 맞는 레이어 추가후 Edit > Project Settings > Physics 에서 설정

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 오브젝트에 PlayerFire 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerFire : MonoBehaviour
{
    // 발사 위치
    public GameObject firePosition;

    // 투척 무기 오브젝트
    public GameObject bombFactory;

    // 투척 파워
    public float throwPower = 15f;

    // 피격 이펙트 오브젝트
    public GameObject bulletEffect;

    // 피격 이펙트 파티클 시스템
    ParticleSystem ps;

    private void Start()
    {
        // 피격 이펙트 오브젝트에서 파티클 시스템 컴포넌트 가져오기
        ps = bulletEffect.GetComponent<ParticleSystem>();
    }
    private void Update()
    {
        // 마우스 오른쪽 버튼을 입력 받음
        if (Input.GetMouseButtonDown(1))
        {
            // 수류탄 오브젝트를 생성한 후 수류탄의 생성 위치를 발사 위치로 변경
            GameObject bomb = Instantiate(bombFactory);
            bomb.transform.position = firePosition.transform.position;

            // 수류탄의 오브젝트의 Rigidbody 컴포넌트를 가져옴
            Rigidbody rb = bomb.GetComponent<Rigidbody>();

            // 카메라의 정면 방향으로 수류탄에 물리적인 힘을 가함 (Impulse : 순간적인 힘)
            rb.AddForce(Camera.main.transform.forward * throwPower, ForceMode.Impulse);
        }

        // 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 피격 이펙트의 위치를 레이가 부딪힌 지점으로 이동
                bulletEffect.transform.position = hitInfo.point;

                /* 피격 이펙트 의  forward 방향을 레이가
                 부딪힌 지점의 법선(부딫힌 면의 수직) 벡터와 일치 시킴 */
                bulletEffect.transform.forward = hitInfo.normal;

                // 피격 이펙트 플레이
                ps.Play();
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

다운 받은 에셋의 Effect > Stone_BulletEffect 프리팹 을 오브젝트로 생성
위치값 0, 1000, 0
스케일 2, 2, 2 로 설정

Player 오브젝트에 BulletEffect 에 참조 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

다운받은 이미지 CrossHair 의 텍스쳐 타입을 Sprite(2D and UI) 로 설정

UI > Image > 이름을 CrossHair 
>위치 센터에 0,0,0
          30, 30

소스 이미지에 CrossHair 이미지 넣기

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

collider : 충돌대상의 가진 충돌체 컴포넌트
point : 충돌한 위치의 좌표
normal : 충돌한 지점의 법선벡터 ( 부딫힌 물체의 수직 벡터)
barycentricCoordinate : 충돌지점의 폴리곤 위치
distance : 레이 발사 지점부터 충돌한 지점까지 거리
.
.
.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 오브젝트 생성

3D 오브젝트 > Capsule > Enemy 로 변경

위치값 -20, 1, 0

적 구분되기 쉽게 마테리얼 추가

Enemy 오브젝트에 Character Controller 추가 > 콜라이더 제거

오브젝트 에 EnemyFSM 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyFSM : MonoBehaviour
{
    // 에너미 상태 상수
    enum EnemyState
    {
        Idle,
        Move,
        Attack,
        Return,
        Damaged,
        Die,
    }

    Coroutine hitCoroutine;

    //에너미 상태 변수
    EnemyState m_State;

    // 플레이어 트랜스폼
    Transform player;

    // 캐릭터 컨트롤러 컴포넌트
    CharacterController cc;

    // 플레이어 발견 범위
    public float findDistance = 8f;
    // 공격 가능 범위
    public float attackDistance = 2f;
    // 공격 딜레이 시간
    float attackDelay = 2f;
    // 에너미 공격력
    public int attackPower = 3;
    // 누적 시간
    float currentTime = 0f;

    // 이동 속도
    public float moveSpeed = 5;

    // 초기 위치 저장
    Vector3 originPos;

    // 이동 가능 위치
    public float moveDistance = 20f;

    // 에너미 의 체력
    public int hp = 15;

    // 에너미의 최대 체력
    int maxHp = 15;

    private void Start()
    {
        // 최초의 에너미 상태를 대기 상태로
        m_State = EnemyState.Idle;

        /* 플레이어 의 트랜트폼 컴포넌트 받아오기
           (오브젝트가 게임 중간에 생성 되기에 미리 참조연결 할 수 없음)  */
        player = GameObject.Find("Player").transform;

        // 캐릭터 컴포넌트 불러오기
        cc = GetComponent<CharacterController>();

        // 자신의 초기 위치값 저장
        originPos = transform.position;
    }

    private void Update()
    {
        // 현재 상태 를 체크해 상태에 따라 메소드 호출
        CheckState();
    }

    void CheckState()
    {
        // 현재 상태 에 따라 메소드 호출
        switch (m_State)
        {
            case EnemyState.Idle:
                Idle();
                break;
            case EnemyState.Move:
                Move();
                break;
            case EnemyState.Attack:
                Attack();
                break;
            case EnemyState.Return:
                Return();
                break;
            case EnemyState.Damaged:
                // Damaged(); 주석 제거 안함
                break;
            case EnemyState.Die:
                // Die();
                break;

            default:
                break;
        }
    }

    void Idle()
    {
        // 만일, 플레이어 와 의 거리가 액션 범위 내라면 Move 로 전환
        if (Vector3.Distance(transform.position, player.position) <= findDistance)
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Idle -> Move");
        }
    }

    void Move()
    {
        // 만일, 현재 위치가 초기 위치에서 이동 가능 범위를 넘어간다면
        if (Vector3.Distance(transform.position, originPos) > moveDistance)
        {
            // 현재 상태를 복귀(Return) 으로 전환
            m_State = EnemyState.Return;
            print("상태 전환 : Move -> Return");
        }
        // 만일, 플레이어 와 의 거리가 공격 범위 밖 이라면 플레이어를 향해 이동
        else if (Vector3.Distance(transform.position, player.position) >= attackDistance)
        {
            // 이동 방향 설정
            Vector3 dir = (player.position - transform.position).normalized;

            // 캐릭터 컨트롤러 를 이용해 이동하기
            cc.Move(dir * moveSpeed * Time.deltaTime);
        }
        // 그렇지 않으면
        else
        {
            m_State = EnemyState.Attack;
            print("상태 전환 : Move -> Attack");

            //누적 시간을 공격 딜레이 시간만큼 미리 진행시켜 놓음
            currentTime = attackDelay;
        }
    }
    
    void Attack()
    {
        // 만일, 플레이어가 공격 범위 이내에 있다면 플레이어를 공격
        if (Vector3.Distance(transform.position, player.position)< attackDistance)
        {
            // 일정한 시간마다 플레이어를 공격
            currentTime += Time.deltaTime;
            if (currentTime > attackDelay)
            {
                player.GetComponent<PlayerMove>().DamageAction(attackPower);
                print("공격");
                currentTime = 0f;
            }
        }
        // 그렇지 않다면, 현재 상태를 이동으로 전환(재추격)
        else
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Attack -> Move");
            currentTime = 0f;
        }
    }

    void Return()
    {
        // 만일, 초기 위치에서 거리가 0.1f 이상이라면 초기 위치 쪽으로 이동
        if (Vector3.Distance(transform.position, originPos) > 0.1f)
        {
            Vector3 dir = (originPos - transform.position).normalized;
            cc.Move(dir * moveSpeed * Time.deltaTime);
        }
        // 그렇지 않다면, 자신의 위치를 초기 위치로 조정하고 현재상태를 대기로 전환
        else
        {
            transform.position = originPos;

            // hp 를 다시 회복
            hp = maxHp;

            m_State = EnemyState.Idle;
            print("상태 전환 : Return -> Idle");
        }
    }

    void Damaged()
    {
        // 피격 상태를 처리하기 위한 코루틴 실행
        hitCoroutine = StartCoroutine(DamagedProcess());
    }

    // 데미지 처리용 코루틴 함수
    IEnumerator DamagedProcess()
    {
        // 피격 모션 시간만큼 기다림
        yield return new WaitForSeconds(0.5f);

        // 현재 상태를 이동 상태로 전환
        m_State = EnemyState.Move;
        print("상태 전환 : Damaged -> Move");
    }

    // 데미지 실행 함수
    // 플레이어 파이어 쪽에서 호출
    public void HitEnemy(int hitPower)
    {
        // 만일, 이미 피격 상태 이거나 사망 상태 또는 복귀 상태라면
        // 아무 처리 하지않고 함수 종료
        if (m_State == EnemyState.Damaged || m_State == EnemyState.Die ||
            m_State == EnemyState.Return)
        {
            return;
        }

        // 플레이어의 공격력 만큼 에너미의 체력을 감소시킴
        hp -= hitPower;

        // 에너미의 체력이 0보다 크면 피격 상태로 전환
        if (hp > 0)
        {
            m_State = EnemyState.Damaged;
            print("상태 전환 : AnyState -> Damaged");
            Damaged();
        }
        // 그렇지 않다면 죽음 상태로 전환
        else
        {
            m_State = EnemyState.Die;
            print("상태 전환 : AnyState -> Die");
            Die();
        }
    }

    void Die()
    {
        // 진행중인 피격 코루틴 중지
        StopCoroutine(hitCoroutine);

        // 죽음 상태를 처리하기 위한 코루틴을 실행
        StartCoroutine(DieProcess());
    }

    IEnumerator DieProcess()
    {
        // 캐릭터 컨틀롤러 컴포넌트를 비활성화
        cc.enabled = false;

        // 2초 동안 기다린 후에 자기 자신을 제거
        yield return new WaitForSeconds(2f);

        print("소멸");
        Destroy(gameObject);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////

적 피격시 체력 달게 만들기

PlayerFire 스크립트에 총알 발사 부분 수정

변수 추가

    // 발사 무기 공격력
    public int weaponPower = 5;

// 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 만일 레이에 부딪힌 대산의 레이어가 "Enemy" 라면 데미지 함수를 실행
                if (hitInfo.transform.gameObject.layer == LayerMask.NameToLayer("Enemy"))
                {
                    EnemyFSM eFsm = hitInfo.transform.GetComponent<EnemyFSM>();
                    eFsm.HitEnemy(weaponPower);
                }
                // 그렇지 않다면 레이에 부딪힌 지점에 피격 이펙트 플레이
                else
                {
                    // 피격 이펙트의 위치를 레이가 부딪힌 지점으로 이동
                    bulletEffect.transform.position = hitInfo.point;

                    /* 피격 이펙트 의  forward 방향을 레이가
                     부딪힌 지점의 법선(부딫힌 면의 수직) 벡터와 일치 시킴 */
                    bulletEffect.transform.forward = hitInfo.normal;

                    // 피격 이펙트 플레이
                    ps.Play();
                }
            }
        }


////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 피격시 데미지 입음

PlayerMove 스크립트에 변수 추가

    // 플레이어 체력
    public int hp = 20;
	
	
	메소드 추가
	
    // 플레이어의 피격 함수
    public void DamageAction(int damage)
    {
        hp -= damage;
    }
	
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 체력바 구현

UI > Slider > HP Bar 로 이름 변경 > Handle 필요 없으니 삭제
위치값 0 -175 0
       300 50

> Imtercatable 비활성화 > Transition : None (클릭 할 일이 없으니 안씀)
> Fill Area 위치값 전부 0으로 > Fill 도 전부 0으로

Fill 색상 적용  


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

PlayerMove 스크립트 수정

추가
using UnityEngine.UI; 

변수 추가

    // 플레이어 체력
    public int hp = 20;
    // 플레이어 최대 체력변수
    int maxHP = 20;

    // hp 슬라이더 변수
    public Slider hpSlider;
	
	
Update() 수정 (이동속도 아래쪽에 넣기)

        // 현재 플레이어 hp(%)를 hp 슬라이더의 value에 반영
        hpSlider.value = (float)hp / maxHP;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 HP 바 생성

Enemy 오브젝트 > UI > Canvas > EnemyCanvas 로 변경

캔바스 랜더모드 World Space 로 설정
위치값 0,0,0
      180,80
	  
EnemyCanvas 자식오브젝트 로 UI > Slider > 이름 EnemyHpBar 로 변경
위치값 0, 1.34, 0
     160, 50

Imtercatable 비활성화, Transition : None

Fill Area 위치값 전부 0
Fill 도 전부 0

EnemyCanvas 스케일 전부 0.01

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 체력바가 카메라 바라보게 스크립트 작성

EnemyCanvas 오브젝트 에 Billboard 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Billboard : MonoBehaviour
{
    // public Transform target;

    private void Update()
    {
        // 자기 자신의 방향을 카메라의 방향과 일치시킴
        transform.forward = Camera.main.transform.forward;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////

피격시 이펙트 생성

Canvas 에 자식 오브젝트로 Image > 이름 Hit 로 설정 > 
앵커포지션 스트래치 스트래치
위치값 0,0,0,
      0,0
	  
색상 255, 0, 0, 130

PlayerMove 스크립트 수정


using 추가

using UnityEngine.UI;

변수 추가

    // hp 슬라이더 변수
    public Slider hpSlider;

    // hit 효과 오브젝트
    public GameObject hitEffect;

	
코루틴 추가 및 매소드 수정

    // 플레이어의 피격 함수
    public void DamageAction(int damage)
    {// 에너미의 공격력만큼 체력을 깎음
        hp -= damage;

        // 피격 이펙트 코루틴을 시작
        StartCoroutine(PlayerHitEffect());
    }

    IEnumerator PlayerHitEffect()
    {
        // 피격 UI 를 활성화
        hitEffect.SetActive(true);

        // 0.3 초간 대기
        yield return new WaitForSeconds(0.3f);

        // 피격 UI 비활성화
        hitEffect.SetActive(false);
    }
	
	참조 연결
	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임 상태 표시하기

레디 상태 > 2초 준비 > 고! > 0.5초 > 게임 시작

빈오브젝트 생성 > 위치값 초기화 > GameManager 로 변경

Canvas 에 UI > Legacy > Text > Text_GameState 로 설정
위치값 0,0,0
      450,100

텍스트 설정
폰트 스타일 Bold, 크기 70, 가운데 정렬


GameManager 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class GameManager : MonoBehaviour
{
    // 싱글톤 변수
    public static GameManager gm;

    private void Awake()
    {
        if (gm == null)
        {
            gm = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // 게임 상태 상수
    public enum GameState
    {
        Ready,
        Run,
        GameOver,
    }

    // 현재 게임 상태 변수
    public GameState gState;

    // 게임상태 UI 오브젝트 변수
    public GameObject gameLabel;
    // 게임 상태 UI 텍스트 컴포넌트 변수
    Text gameText;

    private void Start()
    {
        // 초기 게임 상태를 준비 상태로 설정
        gState = GameState.Ready;

        // 게임 상태 UI 오브젝트에서 Text 컴포넌트를 가져옴
        gameText = gameLabel.GetComponent<Text>();

        // 상태 텍스트의 내용을 'Ready...' 로 설정
        gameText.text = "Ready...";

        // 상태 텍스트의 색상을 주황색으로 설정
        gameText.color = new Color32(255, 185, 0, 255);

        // 게임 준비 -> 게임중으로 상태 전환
        StartCoroutine(ReadyToStart());
    }
    IEnumerator ReadyToStart()
    {
        // 2초간 대기
        yield return new WaitForSeconds(2f);

        // 상태 텍스트의 내용을 "Go!" 로 변경
        gameText.text = "Go!";

        //0.5초 대기
        yield return new WaitForSeconds(0.5f);

        // 상태 텍스트 비활성화
        gameLabel.SetActive(false);

        // 상태를 '게임중' 으로 변경
        gState = GameState.Run;
    }
}


GameManager 오브젝트 Game Label 에 참조 연결(Text_GameState)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임중 상태가 아닐시 조작 불가

CamRotate, PlayerRotate, PlayerFire, PlayerMove
 스크립트 의 Update() 메소드 최상단에
        
// 게임 상태가 '게임중' 상태 일 때만 조작할 수 있게 함
if (GameManager.gm.gState != GameManager.GameState.Run)
	return;
	
추가

////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임 오버 구현

GameManager 스크립트 수정


변수 추가
    // PlayerMove 클래스 변수(player 라고 하면 보통 player 오브젝트를 뜻 하기에 다른이름이 좋다)
    PlayerMove player;


업데이트 메소드
    private void Update()
    {
        // 만일, 플레이어의 hp 가 0 이하라면
        if (player.hp <= 0)
        {
            // 상태 텍스트를 활성화
            gameLabel.SetActive(true);

            //상태 텍스트의 내용을 'GameOver' 로 설정
            gameText.text = "GameOver";

            // 상태 텍스트의 색상을 빨강으로 설정
            gameText.color = new Color32(255, 0, 0, 255);

            // 상태를 '게임 오버' 상태로 변경
            gState = GameState.GameOver;
        }
    }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

알파버전 시작

에셋 스토어에서 좀비 모델링 다운

Zombie 폴더 > FBX > Zombie1 > Model

Scale Factor : 모델의 스케일 값 적용하기전 크기 조정

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Enemy 오브젝트의 자식 오브젝트로 Zombie1 넣기

좀비 오브젝트의 피벗 위치가 발끝 으로 되어있음 좀비 오브젝트의 위치를 이동할 필요가 있음

좀비 오브젝트의 y값을 -1 로

좀비 오브젝트에 콜라이더를 맞추기 위해 Enemy 오브젝트의 콜라이더 수정

Enemy 오브젝트의 Character Controller 
센터값을 0, -0.1, 0
        0.25, 1.8
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

좀비 애니메이션 적용

애니메이터 뷰 설정

프로젝트뷰 Animations 폴더 추가 > Animator Controller 생성 
> Zombie Anim 으로 이름 설정

애니메이터뷰 생성 > 새 스테이트(상태) 추가 > Idle 로 변경 
> Zombie 폴더 안의 Idle 애니메이션 적용(스테이트의 인스펙터뷰에 Motion 에 넣으면 됨)

새 스테이트 생성 > Move > Z_Run_Inplace 넣기

모션 자체에서 위치값이 바뀌는경우 Root Transform 체크 해제 하면 됨

Idle > Move 로 트랜지션 생성 > 파라메터 Trigger 생성 > idleToMove 로 설정

Move > Idle 로 트랜지션 생성 > Trigger 생성 > moveToIdle 로 설정


새 스테이트 2개 생성 > 각각 Attack, AttackDelay 로 설정
> Move 에서 AttackDelay 로 트랜지션 생성 > Trigger 생성 > moveToAttackDelay 로 설정
> Has Exit Time 설정 해제

AttackDelay 에서 Move 로 트랜지션 생성 > Trigger 생성 > attackToMove 로 설정
> Has Exit Time 설정 해제


> AttackDelay 에서 Attack 으로 트랜지션 생성 > Trigger 생성 > startAttack 으로 설정
> Has Exit Time 설정 해제

Attack 에서 AttackDelay 로 가는 트랜지션 생성 > 파라매터 없음, Has Exit Time 활성화

Attack 에서 Move 로 가는 트랜지션 생성 > attackToMove 
> Has Exit Time 설정 해제


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

스크립트 수정

EnemyFSM 스크립트 수정

변수 추가

    // 애니메이터 변수
    Animator anim;


Start() 매소드 수정


    private void Start()
    {
        // 최초의 에너미 상태를 대기 상태로
        m_State = EnemyState.Idle;

        /* 플레이어 의 트랜트폼 컴포넌트 받아오기
           (오브젝트가 게임 중간에 생성 되기에 미리 참조연결 할 수 없음)  */
        player = GameObject.Find("Player").transform;

        // 캐릭터 컴포넌트 불러오기
        cc = GetComponent<CharacterController>();

        // 자신의 초기 위치값 저장
        originPos = transform.position;
        originRot = transform.rotation;

        // 자식 오브젝트로부터 애니메이터 변수 받아오기
        anim = GetComponentInChildren<Animator>();
    }
	
	
각 상태에 맞는 메소드 수정

    void Idle()
    {
        // 만일, 플레이어 와 의 거리가 액션 범위 내라면 Move 로 전환
        if (Vector3.Distance(transform.position, player.position) <= findDistance)
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Idle -> Move");
// 수정된 부분
            // 이동 애니메이션으로 전환
            anim.SetTrigger("idleToMove");
        }
    }
	
	
    void Move()
    {
        // 만일, 현재 위치가 초기 위치에서 이동 가능 범위를 넘어간다면
        if (Vector3.Distance(transform.position, originPos) > moveDistance)
        {
            // 현재 상태를 복귀(Return) 으로 전환
            m_State = EnemyState.Return;
            print("상태 전환 : Move -> Return");
        }
        // 만일, 플레이어 와 의 거리가 공격 범위 밖 이라면 플레이어를 향해 이동
        else if (Vector3.Distance(transform.position, player.position) >= attackDistance)
        {
            // 이동 방향 설정
            Vector3 dir = (player.position - transform.position).normalized;

            // 캐릭터 컨트롤러 를 이용해 이동하기
            cc.Move(dir * moveSpeed * Time.deltaTime);


// 수정된 부분 (바라보는 방향)
            // 플레이어 향해 방향 전환
            transform.forward = dir;
        }
        // 그렇지 않으면, 현재 상태를 공격(Attack) 으로 전환
        else
        {
            m_State = EnemyState.Attack;
            print("상태 전환 : Move -> Attack");

            //누적 시간을 공격 딜레이 시간만큼 미리 진행시켜 놓음
            currentTime = attackDelay;

// 수정된 부분
            //공격 대기 애니메이션 플레이
            anim.SetTrigger("moveToAttackDelay");
        }
    }
	
	
	    void Attack()
    {
        // 만일, 플레이어가 공격 범위 이내에 있다면 플레이어를 공격
        if (Vector3.Distance(transform.position, player.position)< attackDistance)
        {
            // 일정한 시간마다 플레이어를 공격
            currentTime += Time.deltaTime;
            if (currentTime > attackDelay)
            {
			
// 수정된 부분 (애니메이션에서 플레이어 피격함수 호출)
                // player.GetComponent<PlayerMove>().DamageAction(attackPower);
                print("공격");
                currentTime = 0f;
// 수정된 부분
                // 공격 애니메이션 실행
                anim.SetTrigger("startAttack");
            }
        }
        // 그렇지 않다면, 현재 상태를 이동으로 전환(재추격)
        else
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Attack -> Move");
            currentTime = 0f;
// 수정된 부분
            // 공격 상태에서 이동상태로 전환
            anim.SetTrigger("attackToMove");
        }
    }
	
// 자식오브젝트의 애니메이션 에서 이벤트로 불러올수있게 함수 생성
	    public void AttackAction()
    {
        player.GetComponent<PlayerMove>().DamageAction(attackPower);
    }

	
    void Return()
    {
        // 만일, 초기 위치에서 거리가 0.1f 이상이라면 초기 위치 쪽으로 이동
        if (Vector3.Distance(transform.position, originPos) > 0.1f)
        {
            Vector3 dir = (originPos - transform.position).normalized;
            cc.Move(dir * moveSpeed * Time.deltaTime);

// 수정된 부분(복귀시 방향 전환)
            // 복귀 지점으로 방향 전환 
            transform.forward = dir;
        }
        // 그렇지 않다면, 자신의 위치를 초기 위치로 조정하고 현재상태를 대기로 전환
        else
        {
            transform.position = originPos;
            transform.rotation = originRot;

            // hp 를 다시 회복
            hp = maxHp;

            m_State = EnemyState.Idle;
            print("상태 전환 : Return -> Idle");
// 수정된 부분
            // 대기 애니메이션 재생
            anim.SetTrigger("moveToIdle");
        }
    }
	
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

피격시 애니메이션 구현

애니메이터뷰 에서 새 상태 생성 > Damaged 로 설정

에셋 다운로드(Zombie Reaction Hit.FBX) 
기존의 에셋스토어에서 받은 에셋은 피격 애니메이션이 없음

파일을 Zombie 폴더 안에 넣기 (Mixamo 에서 다운받았기 때문에 이름 변경 필요)

Zombie Reaction Hit 클릭 > 인스펙터뷰에 Rig > 애니메이션 타입을 Humanoid 로 변경

Zombie Reaction Hit 클릭 > 인스펙터뷰 Animation 
> 중간쯤 Mixamo 이름을 ZombieHit 으로 변경(자동으로 애니메이션 이름이 바뀜)

애니메이터뷰 Damaged 상태에 ZombieHit 애니메이션 넣기
> AnyState 에서 Damaged 로 가는 트랜지션 생성 > Trigger 생성 > damaged 로 설정
Damaged 에서 Move 로 가는 트랜지션 생성 > 조건 없음 > Has Exit Time 체크 해제 안함

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

스크립트 수정

EnemyFSM 수정 

피격시 실행될 매소드 HitEnemy() 매소드 수정

    // 데미지 실행 함수
    // 플레이어 파이어 쪽에서 호출
    public void HitEnemy(int hitPower)
    {
        // 만일, 이미 피격 상태 이거나 사망 상태 또는 복귀 상태라면
        // 아무 처리 하지않고 함수 종료
        if (m_State == EnemyState.Damaged || m_State == EnemyState.Die ||
            m_State == EnemyState.Return)
        {
            return;
        }

        // 플레이어의 공격력 만큼 에너미의 체력을 감소시킴
        hp -= hitPower;

        // 에너미의 체력이 0보다 크면 피격 상태로 전환
        if (hp > 0)
        {
            m_State = EnemyState.Damaged;
            print("상태 전환 : AnyState -> Damaged");
// 수정된 부분
            // 피격 애니메이션을 플레이
            anim.SetTrigger("damaged");

            Damaged();
        }
        // 그렇지 않다면 죽음 상태로 전환
        else
        {
            m_State = EnemyState.Die;
            print("상태 전환 : AnyState -> Die");
            Die();
        }
    }
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

피격 애니메이션 진행중 이어도 이동하는 문제가 생김

간단한 방법으로는 애니메이션 속도를 증가 시킴
Damaged 상태의 스피드 값을 2로 증가 시킴

그런데도 이동하는 문제가 생김
ZombieHit 애니메이션이 30프레임 에 1초 인 애니메이션 임


    // 데미지 처리용 코루틴 함수
    IEnumerator DamagedProcess()
    {
// 수정된 부분(0.5f 에서 1f 로 변경)
        // 피격 모션 시간만큼 기다림
        yield return new WaitForSeconds(1f);

        // 현재 상태를 이동 상태로 전환
        m_State = EnemyState.Move;
        print("상태 전환 : Damaged -> Move");
    }
	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Die 애니메이션 추가

애니메이터뷰 에 새 상태 Die 추가

AnyState 에서 Die 로가는 트랜지션 생성 > Trigger 생성 > die


EnemyFSM 스크립트 수정

Die() 메소드를 불러오는 HitEnemy() 메소드 수정

    // 데미지 실행 함수
    // 플레이어 파이어 쪽에서 호출
    public void HitEnemy(int hitPower)
    {
        // 만일, 이미 피격 상태 이거나 사망 상태 또는 복귀 상태라면
        // 아무 처리 하지않고 함수 종료
        if (m_State == EnemyState.Damaged || m_State == EnemyState.Die ||
            m_State == EnemyState.Return)
        {
            return;
        }

        // 플레이어의 공격력 만큼 에너미의 체력을 감소시킴
        hp -= hitPower;

        // 에너미의 체력이 0보다 크면 피격 상태로 전환
        if (hp > 0)
        {
            m_State = EnemyState.Damaged;
            print("상태 전환 : AnyState -> Damaged");

            // 피격 애니메이션을 플레이
            anim.SetTrigger("damaged");

            Damaged();
        }
        // 그렇지 않다면 죽음 상태로 전환
        else
        {
            m_State = EnemyState.Die;
            print("상태 전환 : AnyState -> Die");
// 수정된 부분
            // 죽음 애니메이션 재생
            anim.SetTrigger("die");

            Die();
        }
    }
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어의 모델링 변경

에셋 스토어 Soldier 검색

모션을 따로 변경하지 않을 예정이라 휴머노이드로 변경 안함

Legacy : 리타겟팅 불가 , 스크립팅 불가
Generic : 리타겟팅 불가 , 스크립팅 가능
Humanoid : 리타겟팅 가능, 스크립팅 가능

Soldier_demo 를 Player 오브젝트의 자식 오브젝트 로 추가
위치값 y만 -1 넣기

좀비 오브젝트와 비교했을때 크기 차이가 많이남

프로젝트뷰 Soldier_demo 클릭 인스펙터뷰 Model 
> Scale Factor 값 0.7 로 변경 (이미 오브젝트로 만들어도 같이 크기 변경됨)

Player 오브젝트의 Mesh Renderer 체크 해제

Character Controller 값 변경
센터값 0, 0.06, 0
      0.4, 1.8

Skin Width : 기본 충돌영역(콜라이더) 에서 값만큼 더 감지범위 확장(물리 효과는 없음, 감지만함)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

프로젝트뷰 Animations 폴더에 애니메이션 생성 > Soldier Anim 으로 설정

Player 오브젝트 의 자식오브젝트 의 Soldier_demo 에 적용

Soldier Anim 에 다운받은 에셋 의 Animation 인 demo_combat_idle 을 끌어넣기

//////////////////////////////////////////////////////////////////////////////////////////////////////

실행 했을때 카메라 위치 수정이 필요할수 있음

실행 시킨뒤 캠 조정 후 값을 기억했다 수정

CamPosition 값을 0.08, 0.55, 0.2

MainCamera 의 Camera 컴포넌트 > Clipping Planes 수정(실제로 보이는 구간)
값 0.15, 1000

////////////////////////////////////////////////////////////////////////////////

블랜드 트리

값에 따라 애니메이션 처리

Soldier Anim 선택 > 우클릭 New State > New BlendTree > MoveBlend 로 설정

더블클릭으로 들어간뒤 Blend Tree 선택 > 인스펙터뷰 Motion 에 + 를 눌러 Add MotionmField
총 2개의 모션 필드 생성

각각 모션에 다운받은 에셋의 모션 Idle, Run 넣기

블렌드 트리로 Idle 모션과 Run 모션 왔다갔다 할수 있으니 기존의 Idle 모션은 필요 없어짐

기존의 Idle 모션 제거 후 추가한 MoveBlend 를 기본 스테이트로 설정

///////////////////////////////////////////////////////////////////////////////////////////////

PlayerMove 스크립트 수정

변수 추가

    // 애니메이터 변수
    Animator anim;

Start() 수정

    private void Start()
    {
        // 캐릭터 컨트롤러 컴포넌트 받아오기
        cc = GetComponent<CharacterController>();

        // 자식 오브젝트의 애니메이터 받아오기
        anim = GetComponentInChildren<Animator>();
    }

Update() 수정

    private void Update()
    {
        // 게임 상태가 '게임중' 상태 일 때만 조작할 수 있게 함
        if (GameManager.gm.gState != GameManager.GameState.Run)
            return;

        // 사용자의 입력을 받음
        float h = Input.GetAxisRaw("Horizontal");
        float v = Input.GetAxisRaw("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        // nomalized : 벡터의 방향으로 값을 1로
        dir = dir.normalized;

        // 이동 블랜딩 트리를 호출하고 벡터의 크기 값을 넘겨줌(블랜드 트리의 파라메터는 float임)
        // magnitude : 벡터의 길이
        anim.SetFloat("moveMotion", dir.magnitude);

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

공격 애니메이션 추가

애니메이터뷰 에 공격 애니메이션 demo_combat_shoot 넣기

MoveBlend 에서 Attack 으로 가는 트랜지션 생성 > Trigger 생성 > attack 으로 설정
> Has Exit Time 체크 해제

Attack 에서 MoveBlend 로 가는 트랜지션 생성 > 파라매터 없음 Has Exit Time 체크해제 안함


PlayerFire 스크립트 수정

변수 추가

// 애니메이터 변수
    Animator anim;
	

Start() 수정

private void Start()
    {
        // 피격 이펙트 오브젝트에서 파티클 시스템 컴포넌트 가져오기
        ps = bulletEffect.GetComponent<ParticleSystem>();
// 수정된 부분
        // 자식오브젝트의 애니메이터 불러오기
        anim = GetComponentInChildren<Animator>();
    }
	
	
Update() 수정

        // 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
// 수정된 부분
            // 만일 이동 블랜드 트리 파라미터의 값이 0 이라면, 공격 애니메이션 실시
            if (anim.GetFloat("moveMotion") == 0)
            {
                anim.SetTrigger("attack");
            }

            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 사망시 움직이는 애니메이션 안하게 수정


GameManager 스크립트 수정

private void Update()
    {
        // 만일, 플레이어의 hp 가 0 이하라면
        if (player.hp <= 0)
        {
// 수정된 부분     
	        // 플레이어의 애니메이션을 멈춤
            player.GetComponentInChildren<Animator>().SetFloat("moveMotion", 0f);
            
            // 상태 텍스트를 활성화
            gameLabel.SetActive(true);

            //상태 텍스트의 내용을 'GameOver' 로 설정
            gameText.text = "GameOver";

            // 상태 텍스트의 색상을 빨강으로 설정
            gameText.color = new Color32(255, 0, 0, 255);

            // 상태를 '게임 오버' 상태로 변경
            gState = GameState.GameOver;
        }
    }
	
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

길찾기

좌선법,우선법 : 벽에 손을 짚고 한 방향 (좌,우) 으로만 이동하여 경로를 탐색

깊이 우선 탐색(DFS), 넓이 우선 탐색(BFS)
막다른 길이 나올 때까지 경로 탐색 후 다른 경로를 탐색하거나(DFS), 
모든 갈림길을 가까운 곳부터 탐색 하여 점점 먼 방향으로 경로 탐색 범위를 넓힘(BFS)

다익스트라 알고리즘(Dijkstar algorithm)
경우의 수만큼 분신을 만들어서 경로를 탐색 후 
가장 최단 거리의 분신이 이동한 경로를 최종 경로로 찾아내는 알고리즘

A*알고리즘(A*algorithm)
다익으스타 알고리즘의 개량형, 현재 위치에서 목표에 가장 가ㅏㄲ운 이웃 노드를 검색하여
최단 경로를 찾아내는 알고리즘

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

빈오브젝트로 Environment 생성 > Ground, Block 넣기

Environment 의 자식 오브젝트로 3D > Cube 생성 > Obstacle

위치값 -10, 0.5, 0
스케일    2, 1, 3

Environment 를 Navigation Static 설정(자식 오브젝트까지)

Window > AI > Navigation 

Bake 값 
Radius : 0.3
Height : 1.8

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Enemy 오브젝에 Nav Mesh Agent 컴포넌트 넣기
Obstacle Avoidance 에 Radius 와 Height 값을 Environment Bake 했던값이랑 똑같이

EnemyFSM 스크립트 수정

using 추가

using UnityEngine.AI 추가


변수 추가

    // 내비게이션 에이전트 변수
    NavMeshAgent smith;


Move() 수정

    void Move()
    {
        // 만일, 플레이어 와 의 거리가 공격 범위 밖 이라면 플레이어를 향해 이동
        else if (Vector3.Distance(transform.position, player.position) > attackDistance)
        {
            // 내비게이션 으로 접근하는 최소 거리를 공격 가능 거리로 설정
            smith.stoppingDistance = attackDistance;

            // 내비게이션의 목적지를 플레이어의 위치로 설정
            smith.destination = player.position;

        }        
		// 그렇지 않으면, 현재 상태를 공격(Attack) 으로 전환
        else
        {
            // 내비게이션 에이전트의 이동을 멈추로 경로를 초기화
            smith.isStopped = true;
            smith.ResetPath();

            m_State = EnemyState.Attack;
            print("상태 전환 : Move -> Attack");

            //누적 시간을 공격 딜레이 시간만큼 미리 진행시켜 놓음
            currentTime = attackDelay;

            //공격 대기 애니메이션 플레이
            anim.SetTrigger("moveToAttackDelay");
        }
		
		
Return() 수정

 void Return()
    {
        // 만일, 초기 위치에서 거리가 0.1f 이상이라면 초기 위치 쪽으로 이동
        if (Vector3.Distance(transform.position, originPos) > 0.1f)
        {
            // 내비게이션 의 목적지를 초기 저장된 위치로 설정
            smith.destination = originPos;

            // 내비게이션으로 접근하는 최소 거리를 0 으로 설정
            smith.stoppingDistance = 0f;
        }
		// 그렇지 않다면, 자신의 위치를 초기 위치로 조정하고 현재상태를 대기로 전환
        else
        {
            // 내비게이션 에이전트의 이동을 멈추고 경로를 초기화
            smith.isStopped = true;
            smith.ResetPath();

            // 위치값과 회전 값을 초기 상태로 변환
            transform.position = originPos;
            transform.rotation = originRot;

            // hp 를 다시 회복
            hp = maxHp;

            m_State = EnemyState.Idle;
            print("상태 전환 : Return -> Idle");

            // 대기 애니메이션 재생
            anim.SetTrigger("moveToIdle");
        }
    }
	
	
	
HitEnemy() 매소드 수정

public void HitEnemy(int hitPower)
    {
        // 만일, 이미 피격 상태 이거나 사망 상태 또는 복귀 상태라면
        // 아무 처리 하지않고 함수 종료
        if (m_State == EnemyState.Damaged || m_State == EnemyState.Die ||
            m_State == EnemyState.Return)
        {
            return;
        }

        // 내비게이션 에이전트의 이동을 멈추고 경로를 초기화
        smith.isStopped = true;
        smith.ResetPath();

        // 플레이어의 공격력 만큼 에너미의 체력을 감소시킴
        hp -= hitPower;

        // 에너미의 체력이 0보다 크면 피격 상태로 전환
        if (hp > 0)
        {
            m_State = EnemyState.Damaged;
            print("상태 전환 : AnyState -> Damaged");

            // 피격 애니메이션을 플레이
            anim.SetTrigger("damaged");

            Damaged();
        }
		
		
Enemy 오브젝트의 NavMeshAgent 컴포넌트 수정

Speed 			  : 5
Angular Speed     : 1000
Acceleration      : 50
Stopping Distance : 0
AutoBraking 	  : True

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

무기 모드 추가 및 효과 적용

1. 무기 모드 변수 추가
2. 스나이퍼 모드 기능 추가
3. 키보드 입력에 따라 무기 모드를 변경


PlayerFire 스크립트 수정

변수 추가

    //무기 모드 변수
    enum WeaponMode
    {
        Normal,
        Sniper,
    }
    // 카메라 확대 확인용 변수
    WeaponMode wMode;

    bool zoomMode = false;

	
메소드 수정

// 마우스 오른쪽 버튼을 입력 받음
        if (Input.GetMouseButtonDown(1))
        {
            switch (wMode)
            {
                case WeaponMode.Normal:
                    // 수류탄 오브젝트를 생성한 후 수류탄의 생성 위치를 발사 위치로 변경
                    GameObject bomb = Instantiate(bombFactory);
                    bomb.transform.position = firePosition.transform.position;

                    // 수류탄의 오브젝트의 Rigidbody 컴포넌트를 가져옴
                    Rigidbody rb = bomb.GetComponent<Rigidbody>();

                    // 카메라의 정면 방향으로 수류탄에 물리적인 힘을 가함 (Impulse : 순간적인 힘)
                    rb.AddForce(Camera.main.transform.forward * throwPower, ForceMode.Impulse);
                    break;
                
                case WeaponMode.Sniper:
                    // 만일, 줌 모드 상태가 아니라면 카메라를 확대 하고 줌 모드 상태로 변경
                    if (!zoomMode)
                    {
                        Camera.main.fieldOfView = 15f;
                        zoomMode = true;
                    }
                    else
                    {
                        Camera.main.fieldOfView = 60f;
                        zoomMode = false;
                    }
                    break;
                default:
                    break;
            }
        }
		
		
		마우스 입력 if 및에 하나 더 추가
		
		// 만일 키보드의 숫자 1번 입력을 받으면, 무기 모드를 일반 모트로 변경
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            wMode = WeaponMode.Normal;

            // 카메라의 화면을 다시 원래대로 돌려줌
            Camera.main.fieldOfView = 60;
            zoomMode = false;
        }
        // 만일 키보드의 숫자 2번입ㄹ혁을 받으면, 무기 모드를 스나이퍼 모드로 변경
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            wMode = WeaponMode.Sniper;
        }
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

줌 하는 방식은 크게 두가지 방식 이 있음
1. 카메라 자체를 가까이 두기
2. 카메라의 시야각을 줄이기

카메라 시야각은 카메라 컴포넌트의 FOV(Field Of View) 값 을 수정 


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

모드 확인용 UI 생성

Canvas 에 Text 생성 Text_WeaponMode 로 설정

위치값 -75,-150,0
          150,30
		  
Text : Normal Mode

나머지 자율

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

PlayerFire 스크립트 수정

using 추가

using UnityEngine.UI;


변수 추가

    // 무기 모드 텍스트
    public Text wModeText;
	

메소드 수정

// 만일 키보드의 숫자 1번 입력을 받으면, 무기 모드를 일반 모트로 변경
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            wMode = WeaponMode.Normal;

            // 일반 모드 텍스트 출력
            wModeText.text = "Normal Mode";

            // 카메라의 화면을 다시 원래대로 돌려줌
            Camera.main.fieldOfView = 60;
            zoomMode = false;
        }
        // 만일 키보드의 숫자 2번 입력을 받으면, 무기 모드를 스나이퍼 모드로 변경
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            wMode = WeaponMode.Sniper;

            // 스나이퍼 모드 텍스트 출력
            wModeText.text = "Sniper Mode";
        }
		
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 오브젝트 의 W Mode Text 에 참조연결 (Canvas 의 Text_WeaponMode)

에셋 스토어 에서 에셋 다운 easyFPS

MuzzleFlash 폴더 안에 MuzzlePrefabs 의 muzzleFlash 01 ~ 05 까지 오브젝트로 만든뒤 스크립트 비활성화

Player 오브젝트의 자식 오브젝트를 쭉 내려가 Bip001 R Finger0Nub 까지 간뒤
Bip001 R Finger0Nub 의 자식 오브젝트 로 빈 오브젝트 추가
> Muzzle Position 으로 변경

테스트 상태에서 모션 위치 를 볼때 총구 끝에 위치 하도록 위치 조정

추가 했던 muzzleFlash 01 ~ 05 를 Muzzle Position 의 자식 오브젝트로 넣기

muzzleFlash 오브젝트들의 위치값 초기화 모든 스케일 0.4 로 설정


PlayerFire 스크립트 수정

변수 추가

    // 총발사 효과 모음
    public GameObject[] effects;
	

코루틴 추가

    // 총구 이펙트 코루틴 함수
    IEnumerator ShootEffectOn(float duration)
    {
        // 랜덤하게 숫자를 뽑음
        int num = Random.Range(0, effects.Length);
        // 이펙트 오브젝트 배열에서 뽑힌 숫자에 해당하는 이펙트 오브젝트를 활성화
        effects[num].SetActive(true);
        // 지정한 시간 만큼 기다림
        yield return new WaitForSeconds(duration);
        // 이펙트 오브젝트를 비활성화
        effects[num].SetActive(false);
    }
	

// 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 만일 이동 블랜드 트리 파라미터의 값이 0 이라면, 공격 애니메이션 실시
            if (anim.GetFloat("moveMotion") == 0)
            {
                anim.SetTrigger("attack");
            }

            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 만일 레이에 부딪힌 대산의 레이어가 "Enemy" 라면 데미지 함수를 실행
                if (hitInfo.transform.gameObject.layer == LayerMask.NameToLayer("Enemy"))
                {
                    내용 생략
                }
                // 그렇지 않다면 레이에 부딪힌 지점에 피격 이펙트 플레이
                else
                {
				    내용 생략
                }
            }
// 수정된 부분
            // 총 이펙트를 실시
            StartCoroutine(ShootEffectOn(0.05f));
        }	


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 오브젝트 에 PlayerFire 부분 Effects 배열에
추가했던 muzzleFlash 01 ~ 05 참조 연결


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

수류탄 
에셋 다운로드

Prefab 폴더(내가만든) 에 Bomb 프리팹 클릭 
Bomb 프리팹에 자식 오브젝트로 다운받은 수류탄 프리팹 추가
Bomb 의 매쉬 랜더러 비활성


BombAction 스크립트 수정

변수 추가

    // 수류탄 데미지
    public int attackPower = 10;

    // 폭발 효과 반경
    public float explosionRadius = 5f;
	

OnCollisionEnter() 수정

    private void OnCollisionEnter(Collision collision)
    {
        // 폭발 효과 반경 내에서 레이어가 "Enemy" 인 모근 게임 오브젝트 들의
        // Collider 컴포넌트를 배열에 저장
        int enemyLayer = LayerMask.NameToLayer("Enemy");
        /* 8번 레이어 일경우 2^8 이기에 시프트 연산자로 8자리를 자리옮김(비트로 처리)
           00100010000 이면 8번 레이어와 4번 레이어 둘다 확인 가능

           두개 이상 레이어 하고 싶으면( 1 << enemyLayer | 다른 레이어 )
           이런식으로 하면 됨 */
        Collider[] cols = Physics.OverlapSphere(
            transform.position, explosionRadius, 1 << enemyLayer);

        // 저장된 Collider 배열의 있는 모든 에너미에세 수류탄 데미지를 적용
        for (int i = 0; i < cols.Length; i++)
        {
            cols[i].GetComponent<EnemyFSM>().HitEnemy(attackPower);
        }

        // 이펙트 프리팹 생성
        GameObject eff = Instantiate(bombEffect);

        // 이펙트의 위치는 자기 자신과 동일
        eff.transform.position = transform.position;

        // 자기자신 제거
        Destroy(gameObject);
    }
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Enemy 오브젝트를 Prefab 폴더에 넣어 프리팹으로 만들기

Enemy 오브젝트 여러마리 배치 후 수류탄 테스트



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

베타 제작

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

옵션 UI 제작

톱니모양 PNG 다운 후 Materials 폴더에 넣고 텍스쳐 타입 을 Sprite (2D and UI)

Canvas 에 UI > Legacy > Button > Button_Option 으로 설정

앵커 포지션 탑 라이트
위치값 -30,-30,0
          30,30
		  
이미지를 다운받은 이미지로 교체


Canvas 에 UI > Image > Option_Background 로 설정

앵커 포지션 스트래치 스트래치
위치값 200,100,0
       200, 100
	   
색상 변경
0, 0, 0, 192


Option_Background > UI > Legacy > Text > Text_Option 으로 설정

앵커 포지션 센터 미들
위치값 0,140,0
     200, 100

텍스트 : -OPTION-
폰트 스타일 : 볼드
폰트 사이즈 : 25
가운데 정렬

Option_Background 에 UI > Legacy > Button > Button_Resume

앵커 포지션 센터 미들
위치값 0, 60, 0
       200, 40
	   
텍스트 : 계속하기
폰트 사이즈 : 20


Button_Resume 복제 > Button_Restart 로 설정

위치값 y축 0 으로
텍스트 : 다시하기

Button_Restart 복제 > Button_Quit 로 설정

위치값 y축 -60 으로
텍스트 : 나가기


GameManager 스크립트 수정


변수 수정

    public enum GameState
    {
        Ready,
        Run,
        Pause,
        GameOver,
    }
	
	

변수 추가

    // 옵션 화면 UI 오브젝트 변수
    public GameObject gameOption;
	
	
	
메소드 추가

    // 옵션 화면 켜기
    public void OpenOptionWindow()
    {
        // 옵션창 활성화
        gameOption.SetActive(true);

        // 게임 속도를 0배속으로
        Time.timeScale = 0f;

        // 게임상태 를 Pause(일시정지) 로 변경
        gState = GameState.Pause;
    }

    // 계속하기 옵션
    public void CloseOptionWindow()
    {
        // 옵션창 을 비활성화
        gameOption.SetActive(false);

        // 게임 속도를 1배속으로 전환
        Time.timeScale = 1f;

        // 게임 상태를 게임중(Run) 으로 변경
        gState = GameState.Run;
    }
	
	
GameManager 오브젝트에 GameOption 칸에 Option_Background 참조연결

Button_Option 의 OnClicked() 칸에 GameManager 참조 > OpenOptionWindow() 실행
Button_Resume 의 OnClicked() 칸에 GameManager 참조 > CloseOptionWindow() 실행

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

재시작 기능, 게임종료 추가

GameManager 스크립트 수정


using 추가

using UnityEngine.SceneManagement;



메소드 추가

    // 재시작 옵션
    public void RestartGame()
    {
        // 게임 속도 를 1배속으로 전환
        Time.timeScale = 1f;

        // 현재 씬 번호를 다시 로드
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    }

    // 게임 종료 옵션
    public void QuitGame()
    {
        // 애플리케이션 종료
        Application.Quit();
    }
	

Button_Restart 의 OnClicked() 칸에 GameManager 참조 > RestartGame() 실행
Button_Quit 의 OnClicked() 칸에 GameManager 참조 > QuitGame() 실행

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Text_GameState 의 자식오브젝트 로 빈오브젝트 생성 > Buttons 로 설정
> Button_Restart, Button_Quit 을 복제후 넣기

각각 위치값 -150, -80, 0 (다시시작)
           150, -80, 0 (나가기)
		   
Buttons 비활성화


GameManager 스크립트 수정

 private void Update()
    {
        // 만일, 플레이어의 hp 가 0 이하라면
        if (player.hp <= 0)
        {
            // 플레이어의 애니메이션을 멈춤
            player.GetComponentInChildren<Animator>().SetFloat("moveMotion", 0f);
            
            // 상태 텍스트를 활성화
            gameLabel.SetActive(true);

            //상태 텍스트의 내용을 'GameOver' 로 설정
            gameText.text = "GameOver";

            // 상태 텍스트의 색상을 빨강으로 설정
            gameText.color = new Color32(255, 0, 0, 255);

            // 상태 텍스트의 자식 오브젝트의 트랜스폼 컴포넌트를 가져옴(첫번째 자식)
            Transform buttons = gameText.transform.GetChild(0);

            // 버튼 오브젝트를 활성화
            buttons.gameObject.SetActive(true);

            // 상태를 '게임 오버' 상태로 변경
            gState = GameState.GameOver;
        }
    }
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

로그인,비동기 화면(로딩) 구현

백그라운드에 사용할 이미지 다운로드

새로운 씬 만들고 이름을 LoginScene 으로 설정

LoginScene 열기 > UI > RawImage(텍스쳐 타입 안바꿔도 사용가능)
> Background 로 이름 설정

앵커포지션 스트래치 스트래치
위치값 전부 0으로

이미지를 다운받은 이미지로 교체

Canvas 클릭 > Canvas Scaler > UI Scale Mode : Scale With Screen Size
> 1920, 1080

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Canvas 에 자식오브젝트 로 빈 오브젝트 생성 > Input_ID 로 설정
위치값 -53, -70, 0
         100, 100

Input_ID 의 자식오브젝트 로 UI > Legacy > Text 추가 > Text_ID 로 설정
위치값 -130, 0, 0
       200, 60

텍스트 : 아이디
폰트 사이즈 : 40
오른쪽 가운데 정렬


Input_ID 의 자식오브젝트 로 UI > Legacy > Input Field 추가 > InputField_ID 로 설정
위치값  142, 0, 0
         300, 60
		 
자식오브젝트 Placeholder

텍스트 : 아이디 입력
폰트 사이즈 : 33
오른쪽 가운데 정렬

자식오브젝트 Text
폰트 사이즈 : 33
오른쪽 가운데 정렬

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Input_ID 복제 Input_Password 로 설정
위치값 -53, -150, 0
          100, 100
		  
Text_ID 의 이름을 Text_Password 로 변경
> Text_Password 의 텍스트를 : 비밀번호 로 변경

InputField_ID 의 이름을 InputField_Password 로 변경
> 자식오브젝트 의 Placeholder 의 텍스트를 : 비밀번호 입력 으로 변경



Canvas 에 버튼(Legacy) 추가 > Button_Create 로 설정
위치값 -130, -260, 0
            200, 60
텍스트 : 새로 생성
폰트사이즈 : 30


Button_Create 복제 Button_Login 으로 설정
위치값 130, -260, 0
텍스트 : 로그인

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Canvas 에 텍스트(Legacy) 추가 > Text_LoginCheck 로 이름 설정
위치값 0,0,0
   1000, 40   
텍스트 : 아이디 또는 비밀번호가 일치하지 않습니다.
폰트 사이즈 : 30
가운데 정렬


Canvas 에 텍스트(Legacy) 추가 Text_Title 로 설정
위치값 0, 220, 0
      1000, 250
텍스트 : F P S
폰트 스타일 : Bold And Italic
폰트 사이즈 : 180
가운데 정렬

색상 자유


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

로그인 구현

빈오브젝트 생성 후 LoginManager 로 설정 > LoginManager 스크립트 생성

스크립트 작성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class LoginManager : MonoBehaviour
{
    // 유저 아이디 변수
    public InputField id;

    // 유저 패스워드 변수
    public InputField password;

    // 검사 텍스트 변수
    public Text notify;

    private void Start()
    {
        // 검사 텍스트 창을 비움
        notify.text = "";
    }

    // 아이디 와 패스워드 저장 함수
    public void SaveUserData()
    {
        // 만일 입력 검사에 문제가 있으면 함수를 종료
        if (!CheckInput(id.text,password.text))
            return;

        // 만일 시스템에 저장되어 있는 아이디가 존재하지 않는다면
        if (!PlayerPrefs.HasKey(id.text))
        {
            // 사용자의 아이디는 키(key)로 패스워드를 값(value)으로 설정
            PlayerPrefs.SetString(id.text, password.text);
            notify.text = "아이디 생성이 완료 되었습니다";
        }
        // 그렇지 않으면
        else
        {
            notify.text = "이미 존재하는 아이디 입니다.";
        }
    }

    // 로그인 함수
    public void CheckUserData()
    {
        // 만일 입력 검사에 문제가 있으면 함수를 종료
        if (!CheckInput(id.text, password.text))
            return;

        // 사용자가 입력한 아이디를 키(key)로 사용해 시스템에 저장된 값을 불러옴
        string pass = PlayerPrefs.GetString(id.text);

        // 만일, 사용자가 입력한 패스워드와 시스템에서 불러온 값을 비교해서 동일하다면
        if (password.text == pass)
        {
            // 다음 씬(1번 씬)을 로드
            SceneManager.LoadScene(1);
        }
        // 그렇지 않고 두 데이터의 값이 다르면, 유저 정보 불일치 메시지를 남김
        else
        {
            notify.text = "입력하신 아이디 또는 비밀번호 가 일치하지 않습니다.";
        }
    }

    bool CheckInput(string id, string pwd)
    {
        // 만일, 입력란이 하나라도 비어 있으면 유저 정보 입력을 요구
        if (id == "" || pwd == "")
        {
            notify.text = "아이디 또는 비밀번호를 입력해주세요.";
            return false;
        }
        // 입력이 비어있지 않으면
        else
            return true;
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////

Button_Create 의 OnClicked() 에 LoginManager 참조 연결 후 SaveUserData() 연결

비밀번호 입력시 입력값 그대로 보이는 문제가 있음

InputField_Password 의 텍스트 아래쪽 Content Type 을 Password 로 변경


Button_Login 의 OnClicked() 에 LoginManager 참조 연결 후 CheckUserData() 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

비동기 로딩 만들기

동기 : 하나의 작업이 끝나면 다음 작업으로 이동 (직렬)
비동기 : 하나의 작업이 진행중 다른 작업도 진행 (병렬)

새로운 씬 만들기 > LoadingScene

UI > RawImage > Background 로 설정

Background 의 이미지를 Login 이미지 로 설정 > 색상을 조금 어둡게 설정
스트래치 스트래치 0,0,0,0,0

UI > Legacy > Text > LoadingText 로 설정
앵커포지션 바텀 센터 
위치값 563, 76, 0
         130, 60
		 
텍스트 : 90%
폰트사이즈 : 40
가운데 정렬


Canvas 의 Canvas Scaler 를 Scale With Screen Size
> 1920 1080 설정



로딩바 만들기
Canvas > UI > Slider > LoadingBar 로 설정
Interactable 체크 해제

앵커포지션 바텀 센터
위치값 0,80,0
    1000, 50
	
Fill Area, Fill 의 값 전부 0 으로


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

빈 오브젝트 생성 후 이름을 LoadingManager 로 설정
LoadingNextScene 스크립트 생성

스크립트 작성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class LoadingNextScene : MonoBehaviour
{
    // 진행할 씬 번호
    public int sceneNumber = 2;

    // 로딩 슬라이더 바
    public Slider loadingBar;

    // 로딩 진행 텍스트
    public Text loadingText;

    private void Start()
    {
        // 비동기 씬 로드 코루틴을 실행
        StartCoroutine(TransitionNextScene(sceneNumber));
    }

    // 비동기 씬 로드 코루틴
    IEnumerator TransitionNextScene(int num)
    {
        // 지정된 씬을 비동기 형식으로 로드
        // AsyncOperation : 비동기 라는 뜻
        AsyncOperation ao = SceneManager.LoadSceneAsync(num);

        // 로드되는 씬의 모습을 화면에 보이지 않게 함
        ao.allowSceneActivation = false;

        // 로딩이 완료될 때 까지 반복해서 씬의 요소들을 로드하고 진행 과정 을 화면에 표시
        while (!ao.isDone)
        {
            // 로딩 진행률을 슬라이더 바와 텍스트로 표시
            loadingBar.value = ao.progress;
            loadingText.text = (ao.progress * 100f).ToString() + "%";

            // 만일, 씬로드 진행률이 90% 를 넘어가면
            // 0.9 가 최대값임
            if (ao.progress >= 0.9f)
            {
                break;
            }
			
            // 다음 프레임이 될 때까지 기다림
            yield return null;
        }

        loadingBar.value = 1f;
        loadingText.text = "100%";

        yield return new WaitForSeconds(1f);

        // 로드된 씬을 화면에 보이게 함
        ao.allowSceneActivation = true;
    }
}




LoadingManager 에 참조연결

LoadingBar 에 LoadingBar 오브젝트 연결
LoadingText 에 LoadingText 오브젝트 연결

빌드 세팅 > 씬 추가 > 순서를 Login, Loading, MainPlay 순으로 배치

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

GameManager 스크립트 수정

    // 재시작 옵션
    public void RestartGame()
    {
        // 게임 속도 를 1배속으로 전환
        Time.timeScale = 1f;

        // 현재 씬 번호를 다시 로드
        //SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);

        // 로딩 화면 씬을 로드
        SceneManager.LoadScene(1);
    }
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////

UI 레이아웃
Main 씬 의 Canvas 오브젝트의 Canvas Scaler 1920 1080 설정

카페 에서 에셋 다운

IMG_Crosshair 타입을 스프라이트 로 설정
CrossHair 오브젝트 의 소스이미지 교체,
Width 값 100, Height 값 100

IMG_Hpbar, IMG_Hpbar_bg 타입 스프라이트 로 변경
9슬라이스 하기(패키지 없다면 Window > Package Manager > 2D Sprite 다운)

IMG_Hpbar_bg 9슬라이스 값 10,10,10,10
HpBar 오브젝트의 Background 에 넣기

IMG_Hpbar 를 Fill 에 넣기 > Fill Area 값 2, 2, 2, 2 (Pos Z 값 0)


EnemyHpBar 의 Background, Fill 의 이미지를 IMG_Hpbar 로 설정
Slider 값 을 0, -10, 0
               80, 10
			   
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IMG_Crosshair02, Weapon01_gun, Weapon02_sniper 텍스처 타입 스프라이트 로 설정

Text_WeaponMode 앵커포지션 바텀 센터 > 피벗 0.5, 0
위치값 -150, 75, 0
          200, 30
Best Fit 활성

Beat Fit : Min 값 아래로 폰트사이즈 안내려감, Max 값 이상으로 폰트사이즈 안올라감

Canvas 의 자식오브젝트 > UI > Image > Weapon01
앵커포지션 바텀 센터 > 피벗 0.5, 0 

위치값 100, 75, 0
        300, 100
		
Weapon01_gun 이미지 넣기

Weapon01 복제 후 Weapon02_sniper 이미지 넣기

CrossHair 오브젝트 이름 CrossHair01 로 바꾸고 복제 > CrossHair02 로 설정
CrossHair02 의 이미지를 IMG_Crosshair02 로 교체

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

PlayerFire 스크립트 수정

변수 추가

    // 무기 아이콘 스프라이트 변수
    public GameObject weapon01;
    public GameObject weapon02;

    // 크로스헤어 스프라이트 변수
    public GameObject crossHair01;
    public GameObject crossHair02;
	

Update() 수정
        // 만일 키보드의 숫자 1번 입력을 받으면, 무기 모드를 일반 모트로 변경
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            wMode = WeaponMode.Normal;

            // 일반 모드 텍스트 출력
            wModeText.text = "Normal Mode";

            // 카메라의 화면을 다시 원래대로 돌려줌
            Camera.main.fieldOfView = 60;
            zoomMode = false;

            // 1번 스프라이트는 활성화, 2번 스프라이트는 비활성화
            weapon01.SetActive(true);
            crossHair01.SetActive(true);

            weapon02.SetActive(false);
            crossHair02.SetActive(false);
        }
        // 만일 키보드의 숫자 2번입력을 받으면, 무기 모드를 스나이퍼 모드로 변경
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            wMode = WeaponMode.Sniper;

            // 스나이퍼 모드 텍스트 출력
            wModeText.text = "Sniper Mode";

            // 2번 스프라이트는 활성화, 1번 스프라이트는 비활성화
            weapon02.SetActive(true);
            crossHair02.SetActive(true);

            weapon01.SetActive(false);
            crossHair01.SetActive(false);
        }
		

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Weapon01_R_Grenade, Weapon02_R_Sniper 타입 스프라이트 로 설정

Weapon01 복제 Weapon01_R 로 설정
위치값 320, 25, 0
          70, 90

Weapon01_R_Grenade 이미지 넣기

Weapon01_R 복제 Weapon02_R 로 설정 > Weapon02_R_Sniper 이미지 넣기
Width 값 90, Height 값 90


PlayerFire 스크립트 수정

변수추가

    // 마우스 오른쪽 버튼 클릭 아이콘 스프라이트 변수
    public GameObject weapon01_R;
    public GameObject weapon02_R;


Update() 수정한 자리

// 1번 스프라이트는 활성화, 2번 스프라이트는 비활성화
            weapon01.SetActive(true);
            weapon01_R.SetActive(true);
            crossHair01.SetActive(true);

            weapon02.SetActive(false);
            weapon02_R.SetActive(false);
            crossHair02.SetActive(false);
			
반대도 마찬가지 수정


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Canvas > UI > Image > BG 로 설정
앵커포지션, 피벗 0.5, 0
위치값    56, 15, 0
          670, 180
색상 검은색, 알파값 50

BG 를 Canvas 최상단에 위치

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

스나이퍼 조준시 바깥쪽 안보이게 처리

IMG_SniperZoom 타입 스프라이트로

Canvas > UI > Image > Crosshair02_zoom > IMG_SniperZoom 이미지 넣기
Canvas 최상단 배치

PlayerFire 스크립트 수정

변수 추가

    // 마우스 오른쪽 버튼 클릭 줌 모드 스프라이트 변수
    public GameObject crosshair02_zoom;
	
	
switch 문 수정	

                case WeaponMode.Sniper:
                    // 만일, 줌 모드 상태가 아니라면 카메라를 확대 하고 줌 모드 상태로 변경
                    if (!zoomMode)
                    {
                        Camera.main.fieldOfView = 15f;
                        zoomMode = true;

                        // 줌 모드 일때 크로스헤어를 변경
                        crosshair02_zoom.SetActive(true);
                        crossHair02.SetActive(false);
                    }
                    else
                    {
                        Camera.main.fieldOfView = 60f;
                        zoomMode = false;

                        // 크로스헤어를 스나이퍼 모드로 돌려놓기 
                        crosshair02_zoom.SetActive(false);
                        crossHair02.SetActive(true);
                    }
					

if 문 수정

        // 만일 키보드의 숫자 1번 입력을 받으면, 무기 모드를 일반 모트로 변경
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            // 스나이퍼 모드에서 일반 모드 키를 눌렀을때 Weapone01_R_zoom 은 비활성화
            crosshair02_zoom.SetActive(false);
            zoomMode = false;
			

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

마테리얼


프로젝트뷰 폴더 생성 > Art > Material 생성 > Mat_Basic 으로 설정

Albedo : 물체가 지니는 기본색

Metallic : 금속 성분을 나타냄 (0 : 비금속 ~ 1 : 금속)
           비금속 : 빛을 반사 시킬때 조명의 컬러를 더많 이 반사
		     금속 : 빛을 반사 시킬때 물체의 컬러를 더 많이 반사

Smoothness : 표면의 거친 정도를 표현(손으로 만지는 것보다 훨실 미세한 수준을 뜻함)


Normal Map 노멀 맵

리얼타임 렌더링인 유니티에서는 많은수 의 폴리곤(입체) 데이터를 처리하기 곤란

폴리곤의 개수를 적게 초기화 하는 대신 디테일한 정보를 텍스쳐로 만듦(텍스쳐 베이킹)

단순한 외형에 Normal Map 이라는 정보를 덧씌워 컴퓨터에게 표면에 디테일한 입체정보가
있는것처럼 착시를 줌

외형은 바뀌지않지만 조명의 위치나 각도에 따라 음영이 바뀜


프로젝트뷰 검색칸에 Normal Map 검색(푸른색 을 띄는게 노멀맵용 텍스처)
Material 안에 Normal Map 옆에 연결

유니티에 텍스쳐(그림파일) 을 임포트하면 최초 세팅은 Defualt 임
노멀맵으로 사용하려면 테스쳐 타입을 노멀맵으로 변경해야함


Emission(이미션) 스스로 빛을 나타내게 하는 표현을 할때 사용
포스트 프로세싱의 블룸 을 같이 사용하면 빛번짐 극대화 가능

///////////////////////////////////////////////////////////////////////////////////////////////////

파티클 시스템

시간 관련 옵션들 : 초단위 사용
움직임 이나 크기 : 유니티유닛, 배율 단위

오브젝트는 따로 입력 을 주지않으면 계속 존재
이펙트는 생성후 일정시간(StartLifeTime) 후 삭제


다운받은 Asset 인 WarFx 의 Demo 폴더의 WarFx Demo New 열기
+ > Effect > Particle System > FX_Fire 로 설정

위치값  0, 0, 0
     -90, 0, 0
	 
Start Life Time :














/////////////////////////////////////////////////////////////////////////////////////////////

마테리얼 생성

wfx_t_smokeloop 검색 후 Maps > 알베도 옆에 넣기
FX_Fire 가장 하단 Renderer 에 Material 에 넣기

FX_Fire 복제후 FX_Smoke 로 이름 변경후 FX_Fire 의 자식오브젝트 로 넣기
FX_Smoke 의 Z 값을 1 로 설정

//////////////////////////////////////////////////////////////////////////////////////////////////////////

라이트 매핑

Dynamic Object : 움직일수 있는 오브젝트

Static Object : 정적인 오브젝트(컨텐츠가 종료되는 동안 절대 움직이지 않을 오브젝트)

스태틱 오브젝트를 대상으로 라이트에 대한 계산을 미리(제작중)하여
플레이중 컴퓨터계산 의 부담을 감소시킴

인스펙터 오른쪽 상단에 Static 설정으로 사용가능


///////////////////////////////////////////////////////////////////////////////////////////////////////////////

프로젝트뷰 에 다운받은 에셋인 RPG_FPS_game_assets.... 의 Map_v1 씬을
하이어라키뷰에 끌어올린뒤 맵 오브젝트를 가져온뒤 씬 다시 삭제(저장안함 으로)

Environment 오브젝트 비활성화 한뒤 Map_v1 오브젝트 네비게이션 베이크 하기



Directional Light 오브젝트 선택

Light 컴포넌트 > Mode : Mixed

RealTime : 다이나믹 오브젝트에만 영향을 줌
Mixed : 다이나믹,스태틱 오브젝트 둘다 영향을 줌
Baked : 스태틱 오브젝트에만 영향을 줌



Directional Light : 메인 라이트로 빛의 방향과 태양광 과 같은 역할

Point Light : 보조광 으로 다수의 포인트 라이트를 사용하여 부족한 빛의 변화를 위해 사용

Spot Light : 전등이나 조명기구 등 방향성으 가진 조명을 표현 하고자 할때 사용

Area Light(베이크 전용) : 면적 단위로 빛을 내는 역할, 주로 간접등이나 무드등으로 사용


쉐도우 옵션

Soft > Hard > No Shadows 순으로 퀄리티가 낮아짐(성능은 향상됨)


//////////////////////////////////////////////////////////////////////////////////////////////////////

라이트 세팅

Window > Rendering > Lighting Setings

New Lightint Settings > MainScene Lighting Settings 로 설정

GenerateSetting 눌러 조명 설정 가능 (시간 많이걸림)
Lightmap Resolution(조명 해상도) 값을 줄여 시간을 줄일수 있음

Auto Generate 는 작업중 갑자기 실행되어 멈출수 있음

Generate 가 끝나면 씬 이름의 폴더에 조명 파일들이 들어있음
Max Lightmap Size 의 값만큼 파일의 사이즈가 설정됨


구름 만들기
Environment > Skybox Material > 옆의 동그라미 > skybox 검색 후 적용

Environment Lighting
Source
Color : 단색을 활용하여 환경광을 표현(부자연 스러움)

Gradient : 세가지 컬러(Sky,Equator, Ground) 를 사용하여 환경광을 표현(장소변화에 대처가 어려움)

Skybox : Skybox Material 의 Cubemap 이미지를 활용하여 환경광을 표현(자연스러움)



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Scene 설정칸
Mixed Lighting
Baked Global Illumination 체크 할시 라이트맵 생성함

Baked Imdirect : 보편적인 옵션으로 라이트의 간접광만을 미리 계산하기 위한 옵션

Subtaractive : 모바일과 같이 조명의 변화가 적거나 성능이 부족한 기기를 위한 옵션

Shadowmask : 라이트맵 생성시 가장많은 종류의 텍스쳐를 제작하여 적용하기 때문에
             실제 생성되는 이미지가 많아지며 관리가 복잡해짐
			 라이트 베이킹의 성능이 가장 좋음
			
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

라이트 맵에서 '맵' 이라는 것은 결국 Texture(2D 이미지)를 뜻함

Resolution : 이미지 파일을 만들기 위해서는 크기가 얼마나 되는지,(Resolution- 해상도)

Sample : 각 픽셀에 얼마나 정교한 계산결과 를 담을 것인지(Sample 광선 추적 갯수)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Lightmap Resolution 과 Size

Resolution(해상도) : 유니티 유닛(1미터로 주로 사용)을 몇 픽셀로 그릴 것 인지결정
                    1미터를 40 픽셀로 그린다면 정교한 결과를 얻지만 그만큼 계산이 오래걸림

Size(크기) : 라이트맵 텍스쳐 1장의 최대 크기를 결정함

같은 개수의 오브젝트라도 해상도와 크기에 따라 최종 라이트맵의 개수가 결정됨


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Lightmapping Setting
Lightmaper : 라이트를 계산하기 위한 기능

Enlighten 은 사용안함

Progressive CPU : CPU 성능에 따라 라이트맵을 그림
Progressive GPU : 그래픽 가드의 성능을 활용하여 라이트맵을 그림,
                  현재는 프리뷰 기능으로 안정되지 않으나 성능에 따라
				  CPU 보다 빠르게 결과를 만들어낼수있음


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

오브젝트 생성 > Light > Point Light > 플레이어 의 정면에위치 시키기
Intensity 값 5로 설정
Mode : RealTime 으로 되어있음
색상을 빨강으로 한뒤 조명 근처로 가면 플레이어 의 총에 빨간빛 이 들어옴

Mode : Baked 로 한뒤 Generate 를 하면 총구에 빨간빛 이 안들어옴


오브젝트 생성 > Light > Light Prove Groupe
Light Prove Groupe 오브젝트가 플레이어 오브젝트를 감싸게 위치
노란 구체 범위 에 Static 조명이 있을때 Static 조명에도 영향을 받게 설정

문제는 미리 베이크 해놓은것이기 때문에 영역이 작으면
밖에서도 빨간빛이 그대로 들어갈수 있음(조명이 영역보다 클경우)

Light Prove 범위를 늘려 해결 가능

베이크용으로 만든 빛은 베이크 한 후에 꺼도 상관없음

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

반사광 Reflection
오브젝트 생성 > Light > Reflection Prove Groupe
위치값 0, 5, 0

범위 설정후 베이크 하면 반사가 가능한 물체의 텍스쳐를 미리볼수있음

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

포스트 프로세싱

패키지 다운로드
Window > Package Manager > Post Processing
