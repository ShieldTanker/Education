
프로토 타입 단계 부터 시작

씬 이름 변경 > MainScene

바닥 추가
3D 오브젝트 Plane 추가 > Ground 로 이름 변경
스케일 10, 1, 10

프로젝트뷰 Materials 폴더 추가 > 마테리얼 생성 Mat_Ground 로 변경 색 지정
Ground 에 넣기

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Capsule 오브젝트 추가 > Player 로 변경
위치값 0, 1, 0

MainCamera 오브젝트에 CamRotate 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamRotate : MonoBehaviour
{
    // 회전 속도 변수
    public float rotSpeed = 200f;

    float mX = 0f;
    float mY = 0f;

    private void Update()
    {
        // 마우스 입력을 받음
        float mouse_X = Input.GetAxis("Mouse X");
        float mouse_Y = Input.GetAxis("Mouse Y");

        // 회전값 변수에 마우스 입력값만큼 미리 누적
        mX += mouse_X * rotSpeed * Time.deltaTime;
        mY += mouse_Y * rotSpeed * Time.deltaTime;

        // 마우스 상하 이동 회전 변수(mY) 의 값을 -90 ~ 90 도 사이로 제한
        mY = Mathf.Clamp(mY, -90, 90);

        // 마우스 입력 값을 이용해 외전 방향을 결정(X축기준 회전 : 상하, Y축 기준 회전: 좌우)
        // 회전 방향으로 오브젝트 회전
        transform.eulerAngles = new Vector3(-mY, mX, 0);
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 회전 구현

Player 오브젝트에 PlayerRotate 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerRotate : MonoBehaviour
{
    // 회전 속도 변수
    public float rotSpeed = 200f;

    // 회전값 변수
    float mx = 0f;

    private void Update()
    {
        // 마우스 좌우 입력을 받음
        float mouse_X = Input.GetAxis("Mouse X");

        // 회전 값 변수에 마우스 입력 값만큼 미리 누적
        mx += mouse_X * rotSpeed * Time.deltaTime;

        // 회전 방향으로 물체를 회전기킴
        transform.eulerAngles = new Vector3(0, mx, 0);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

카메라 위치를 플레이어 와 동기화

Player 오브젝트에 자식 오브젝트로 빈오브젝트 CamPosition 생성
위치값 0, 0.25, 0

MainCamera 오브젝트에 CamFollow 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamFollow : MonoBehaviour
{
    // 목표가 될 트랜스폼 컴포넌트
    public Transform target;

    private void Update()
    {
        // 카메아의 위치를 목표 트랜스폼의 위치에 일치시킴
        transform.position = target.position;
    }
}

target 에 CamPosition 참조 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 움직임 구현

Player 오브젝트에 PlayerMove 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMove : MonoBehaviour
{
    public float moveSpeed = 7f;

    private void Update()
    {
        // 사용자의 입력을 받음
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        dir = dir.normalized;

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);

        // 이동 속도에 맞춰 이동
        transform.position += dir * moveSpeed * Time.deltaTime;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

중력 적용

위를 바라볼시 공중에 뜨는 문제 해결하기위해 중력 만들기

Player 오브젝트 선택 Character Controller 컴포넌트 추가

Character Controller 에는 이미 Collider 가 있기 때문에 
기존에 있던 Collider 컴포넌트 는 제거

PlayerMove 스크립트 열기

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMove : MonoBehaviour
{
    // 이동 속도 변수
    public float moveSpeed = 7f;

    // 캐릭터 컨트롤러 변수
    CharacterController cc;

    // 중력 변수
    float gravity = -20f;

    // 수직 속도 변수
    [SerializeField]
    float yVelocity = 0f;

    // 점프력 변수
    public float jumpPower = 10f;

    // 점프 상태 변수
    public bool isJumping = false;

    private void Start()
    {
        cc = GetComponent<CharacterController>();
    }

    private void Update()
    {
        // 사용자의 입력을 받음
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        dir = dir.normalized;

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);

        // 점프 후 바닥에 닿은 상태인지 확인
        if (isJumping && cc.collisionFlags == CollisionFlags.Below)
        {
            // 점프 가능하게 변경
            isJumping = false;

            // 캐릭터의 수직속도를 0으로 만듬
            yVelocity = 0f;
        }

        // 만약 Spacebar 키를 입력했으면
        if (Input.GetButtonDown("Jump") && !isJumping)
        {
            // 캐릭터 수직 속도에 점프력 적용
            yVelocity = jumpPower;
            isJumping = true;
        }

        /* 이동 속도에 맞춰 이동 (캐릭터 컨트롤러로 이동함)
        transform.position += dir * moveSpeed * Time.deltaTime; */

        // 캐릭터 수직 속도에 중력 값을 적용
        yVelocity += gravity * Time.deltaTime;
        dir.y = yVelocity;

        // 이동속도에 맞춰 이동
        cc.Move(dir * moveSpeed * Time.deltaTime);
    }
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

수류탄 구현

3D 오브젝트 Sphere > Bomb 으로 변경 > 위치값 초기화

RigidBody 컴포넌트 추가

BombAction 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BombAction : MonoBehaviour
{
    public GameObject bombEffect;


    // 충돌시 처리
    private void OnCollisionEnter(Collision collision)
    {
        // 이펙트 프리팹 생성
        GameObject eff = Instantiate(bombEffect);

        // 이펙트의 위치는 자기 자신과 동일
        eff.transform.position = transform.position;

        // 자기자신 제거
        Destroy(gameObject);
    }
}

Bomb 을 프리팹으로 저장

/////////////////////////////////////////////////////////////////////////////////

에셋다운
에셋의 스크립트 폴더 제거

Exploson1 프리팹 의 스크립트 들 제거, 
자식오브젝트 의 Explosion - [Explosion6] 에 Simulation Speed 값을 2로 설정

프리팹의 부모 오브젝트에 DestroyEffect 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DestroyEffect : MonoBehaviour
{
    // 제거될 시간 변수
    public float destroyTime = 1.5f;

    //경과 시간 측정용 변수
    float currentTime = 0;

    private void Update()
    {
        // 만일 경과 시간이 제거될 시간을 초과하면 자기 자신을 제거
        if (currentTime > destroyTime)
        {
            Destroy(gameObject);
        }
        // 경과시간 누적
        currentTime += Time.deltaTime;
    }
}


위 코드 말고 Start() 에 Destroy(gameObject,1.5f); 해도 똑같음

////////////////////////////////////////////////////////////////////////////////////////////////////

Exploson1 프리팹 저장 후 오브젝트 로 끌어온 뒤 FX_Bomb 으로 이름 변경
자주 사용할 프리팹 폴더를 따로 만들고 그곳에 오리지날 프리팹으로 FX_Bomb 저장

///////////////////////////////////////////////////////////////////////////////////////////////////

BombAction 의 Bomb Effect 칸에 FX_Bomb 을 참조 연결

수류탄이 플레이어 와 닿아도 터지는 문제 를 없애기 위해 Layer 를 추가
각각 오브젝트에 맞는 레이어 추가후 Edit > Project Settings > Physics 에서 설정

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 오브젝트에 PlayerFire 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerFire : MonoBehaviour
{
    // 발사 위치
    public GameObject firePosition;

    // 투척 무기 오브젝트
    public GameObject bombFactory;

    // 투척 파워
    public float throwPower = 15f;

    // 피격 이펙트 오브젝트
    public GameObject bulletEffect;

    // 피격 이펙트 파티클 시스템
    ParticleSystem ps;

    private void Start()
    {
        // 피격 이펙트 오브젝트에서 파티클 시스템 컴포넌트 가져오기
        ps = bulletEffect.GetComponent<ParticleSystem>();
    }
    private void Update()
    {
        // 마우스 오른쪽 버튼을 입력 받음
        if (Input.GetMouseButtonDown(1))
        {
            // 수류탄 오브젝트를 생성한 후 수류탄의 생성 위치를 발사 위치로 변경
            GameObject bomb = Instantiate(bombFactory);
            bomb.transform.position = firePosition.transform.position;

            // 수류탄의 오브젝트의 Rigidbody 컴포넌트를 가져옴
            Rigidbody rb = bomb.GetComponent<Rigidbody>();

            // 카메라의 정면 방향으로 수류탄에 물리적인 힘을 가함 (Impulse : 순간적인 힘)
            rb.AddForce(Camera.main.transform.forward * throwPower, ForceMode.Impulse);
        }

        // 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 피격 이펙트의 위치를 레이가 부딪힌 지점으로 이동
                bulletEffect.transform.position = hitInfo.point;

                /* 피격 이펙트 의  forward 방향을 레이가
                 부딪힌 지점의 법선(부딫힌 면의 수직) 벡터와 일치 시킴 */
                bulletEffect.transform.forward = hitInfo.normal;

                // 피격 이펙트 플레이
                ps.Play();
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

다운 받은 에셋의 Effect > Stone_BulletEffect 프리팹 을 오브젝트로 생성
위치값 0, 1000, 0
스케일 2, 2, 2 로 설정

Player 오브젝트에 BulletEffect 에 참조 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

다운받은 이미지 CrossHair 의 텍스쳐 타입을 Sprite(2D and UI) 로 설정

UI > Image > 이름을 CrossHair 
>위치 센터에 0,0,0
          30, 30

소스 이미지에 CrossHair 이미지 넣기

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

collider : 충돌대상의 가진 충돌체 컴포넌트
point : 충돌한 위치의 좌표
normal : 충돌한 지점의 법선벡터 ( 부딫힌 물체의 수직 벡터)
barycentricCoordinate : 충돌지점의 폴리곤 위치
distance : 레이 발사 지점부터 충돌한 지점까지 거리
.
.
.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 오브젝트 생성

3D 오브젝트 > Capsule > Enemy 로 변경

위치값 -20, 1, 0

적 구분되기 쉽게 마테리얼 추가

Enemy 오브젝트에 Character Controller 추가 > 콜라이더 제거

오브젝트 에 EnemyFSM 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyFSM : MonoBehaviour
{
    // 에너미 상태 상수
    enum EnemyState
    {
        Idle,
        Move,
        Attack,
        Return,
        Damaged,
        Die,
    }

    Coroutine hitCoroutine;

    //에너미 상태 변수
    EnemyState m_State;

    // 플레이어 트랜스폼
    Transform player;

    // 캐릭터 컨트롤러 컴포넌트
    CharacterController cc;

    // 플레이어 발견 범위
    public float findDistance = 8f;
    // 공격 가능 범위
    public float attackDistance = 2f;
    // 공격 딜레이 시간
    float attackDelay = 2f;
    // 에너미 공격력
    public int attackPower = 3;
    // 누적 시간
    float currentTime = 0f;

    // 이동 속도
    public float moveSpeed = 5;

    // 초기 위치 저장
    Vector3 originPos;

    // 이동 가능 위치
    public float moveDistance = 20f;

    // 에너미 의 체력
    public int hp = 15;

    // 에너미의 최대 체력
    int maxHp = 15;

    private void Start()
    {
        // 최초의 에너미 상태를 대기 상태로
        m_State = EnemyState.Idle;

        /* 플레이어 의 트랜트폼 컴포넌트 받아오기
           (오브젝트가 게임 중간에 생성 되기에 미리 참조연결 할 수 없음)  */
        player = GameObject.Find("Player").transform;

        // 캐릭터 컴포넌트 불러오기
        cc = GetComponent<CharacterController>();

        // 자신의 초기 위치값 저장
        originPos = transform.position;
    }

    private void Update()
    {
        // 현재 상태 를 체크해 상태에 따라 메소드 호출
        CheckState();
    }

    void CheckState()
    {
        // 현재 상태 에 따라 메소드 호출
        switch (m_State)
        {
            case EnemyState.Idle:
                Idle();
                break;
            case EnemyState.Move:
                Move();
                break;
            case EnemyState.Attack:
                Attack();
                break;
            case EnemyState.Return:
                Return();
                break;
            case EnemyState.Damaged:
                // Damaged(); 주석 제거 안함
                break;
            case EnemyState.Die:
                // Die();
                break;

            default:
                break;
        }
    }

    void Idle()
    {
        // 만일, 플레이어 와 의 거리가 액션 범위 내라면 Move 로 전환
        if (Vector3.Distance(transform.position, player.position) <= findDistance)
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Idle -> Move");
        }
    }

    void Move()
    {
        // 만일, 현재 위치가 초기 위치에서 이동 가능 범위를 넘어간다면
        if (Vector3.Distance(transform.position, originPos) > moveDistance)
        {
            // 현재 상태를 복귀(Return) 으로 전환
            m_State = EnemyState.Return;
            print("상태 전환 : Move -> Return");
        }
        // 만일, 플레이어 와 의 거리가 공격 범위 밖 이라면 플레이어를 향해 이동
        else if (Vector3.Distance(transform.position, player.position) >= attackDistance)
        {
            // 이동 방향 설정
            Vector3 dir = (player.position - transform.position).normalized;

            // 캐릭터 컨트롤러 를 이용해 이동하기
            cc.Move(dir * moveSpeed * Time.deltaTime);
        }
        // 그렇지 않으면
        else
        {
            m_State = EnemyState.Attack;
            print("상태 전환 : Move -> Attack");

            //누적 시간을 공격 딜레이 시간만큼 미리 진행시켜 놓음
            currentTime = attackDelay;
        }
    }
    
    void Attack()
    {
        // 만일, 플레이어가 공격 범위 이내에 있다면 플레이어를 공격
        if (Vector3.Distance(transform.position, player.position)< attackDistance)
        {
            // 일정한 시간마다 플레이어를 공격
            currentTime += Time.deltaTime;
            if (currentTime > attackDelay)
            {
                player.GetComponent<PlayerMove>().DamageAction(attackPower);
                print("공격");
                currentTime = 0f;
            }
        }
        // 그렇지 않다면, 현재 상태를 이동으로 전환(재추격)
        else
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Attack -> Move");
            currentTime = 0f;
        }
    }

    void Return()
    {
        // 만일, 초기 위치에서 거리가 0.1f 이상이라면 초기 위치 쪽으로 이동
        if (Vector3.Distance(transform.position, originPos) > 0.1f)
        {
            Vector3 dir = (originPos - transform.position).normalized;
            cc.Move(dir * moveSpeed * Time.deltaTime);
        }
        // 그렇지 않다면, 자신의 위치를 초기 위치로 조정하고 현재상태를 대기로 전환
        else
        {
            transform.position = originPos;

            // hp 를 다시 회복
            hp = maxHp;

            m_State = EnemyState.Idle;
            print("상태 전환 : Return -> Idle");
        }
    }

    void Damaged()
    {
        // 피격 상태를 처리하기 위한 코루틴 실행
        hitCoroutine = StartCoroutine(DamagedProcess());
    }

    // 데미지 처리용 코루틴 함수
    IEnumerator DamagedProcess()
    {
        // 피격 모션 시간만큼 기다림
        yield return new WaitForSeconds(0.5f);

        // 현재 상태를 이동 상태로 전환
        m_State = EnemyState.Move;
        print("상태 전환 : Damaged -> Move");
    }

    // 데미지 실행 함수
    // 플레이어 파이어 쪽에서 호출
    public void HitEnemy(int hitPower)
    {
        // 만일, 이미 피격 상태 이거나 사망 상태 또는 복귀 상태라면
        // 아무 처리 하지않고 함수 종료
        if (m_State == EnemyState.Damaged || m_State == EnemyState.Die ||
            m_State == EnemyState.Return)
        {
            return;
        }

        // 플레이어의 공격력 만큼 에너미의 체력을 감소시킴
        hp -= hitPower;

        // 에너미의 체력이 0보다 크면 피격 상태로 전환
        if (hp > 0)
        {
            m_State = EnemyState.Damaged;
            print("상태 전환 : AnyState -> Damaged");
            Damaged();
        }
        // 그렇지 않다면 죽음 상태로 전환
        else
        {
            m_State = EnemyState.Die;
            print("상태 전환 : AnyState -> Die");
            Die();
        }
    }

    void Die()
    {
        // 진행중인 피격 코루틴 중지
        StopCoroutine(hitCoroutine);

        // 죽음 상태를 처리하기 위한 코루틴을 실행
        StartCoroutine(DieProcess());
    }

    IEnumerator DieProcess()
    {
        // 캐릭터 컨틀롤러 컴포넌트를 비활성화
        cc.enabled = false;

        // 2초 동안 기다린 후에 자기 자신을 제거
        yield return new WaitForSeconds(2f);

        print("소멸");
        Destroy(gameObject);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////

적 피격시 체력 달게 만들기

PlayerFire 스크립트에 총알 발사 부분 수정

변수 추가

    // 발사 무기 공격력
    public int weaponPower = 5;

// 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 만일 레이에 부딪힌 대산의 레이어가 "Enemy" 라면 데미지 함수를 실행
                if (hitInfo.transform.gameObject.layer == LayerMask.NameToLayer("Enemy"))
                {
                    EnemyFSM eFsm = hitInfo.transform.GetComponent<EnemyFSM>();
                    eFsm.HitEnemy(weaponPower);
                }
                // 그렇지 않다면 레이에 부딪힌 지점에 피격 이펙트 플레이
                else
                {
                    // 피격 이펙트의 위치를 레이가 부딪힌 지점으로 이동
                    bulletEffect.transform.position = hitInfo.point;

                    /* 피격 이펙트 의  forward 방향을 레이가
                     부딪힌 지점의 법선(부딫힌 면의 수직) 벡터와 일치 시킴 */
                    bulletEffect.transform.forward = hitInfo.normal;

                    // 피격 이펙트 플레이
                    ps.Play();
                }
            }
        }


////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 피격시 데미지 입음

PlayerMove 스크립트에 변수 추가

    // 플레이어 체력
    public int hp = 20;
	
	
	메소드 추가
	
    // 플레이어의 피격 함수
    public void DamageAction(int damage)
    {
        hp -= damage;
    }
	
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 체력바 구현

UI > Slider > HP Bar 로 이름 변경 > Handle 필요 없으니 삭제
위치값 0 -175 0
       300 50

> Imtercatable 비활성화 > Transition : None (클릭 할 일이 없으니 안씀)
> Fill Area 위치값 전부 0으로 > Fill 도 전부 0으로

Fill 색상 적용  


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

PlayerMove 스크립트 수정

추가
using UnityEngine.UI; 

변수 추가

    // 플레이어 체력
    public int hp = 20;
    // 플레이어 최대 체력변수
    int maxHP = 20;

    // hp 슬라이더 변수
    public Slider hpSlider;
	
	
Update() 수정 (이동속도 아래쪽에 넣기)

        // 현재 플레이어 hp(%)를 hp 슬라이더의 value에 반영
        hpSlider.value = (float)hp / maxHP;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 HP 바 생성

Enemy 오브젝트 > UI > Canvas > EnemyCanvas 로 변경

캔바스 랜더모드 World Space 로 설정
위치값 0,0,0
      180,80
	  
EnemyCanvas 자식오브젝트 로 UI > Slider > 이름 EnemyHpBar 로 변경
위치값 0, 1.34, 0
     160, 50

Imtercatable 비활성화, Transition : None

Fill Area 위치값 전부 0
Fill 도 전부 0

EnemyCanvas 스케일 전부 0.01

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 체력바가 카메라 바라보게 스크립트 작성

EnemyCanvas 오브젝트 에 Billboard 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Billboard : MonoBehaviour
{
    // public Transform target;

    private void Update()
    {
        // 자기 자신의 방향을 카메라의 방향과 일치시킴
        transform.forward = Camera.main.transform.forward;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////

피격시 이펙트 생성

Canvas 에 자식 오브젝트로 Image > 이름 Hit 로 설정 > 
앵커포지션 스트래치 스트래치
위치값 0,0,0,
      0,0
	  
색상 255, 0, 0, 130

PlayerMove 스크립트 수정


using 추가

using UnityEngine.UI;

변수 추가

    // hp 슬라이더 변수
    public Slider hpSlider;

    // hit 효과 오브젝트
    public GameObject hitEffect;

	
코루틴 추가 및 매소드 수정

    // 플레이어의 피격 함수
    public void DamageAction(int damage)
    {// 에너미의 공격력만큼 체력을 깎음
        hp -= damage;

        // 피격 이펙트 코루틴을 시작
        StartCoroutine(PlayerHitEffect());
    }

    IEnumerator PlayerHitEffect()
    {
        // 피격 UI 를 활성화
        hitEffect.SetActive(true);

        // 0.3 초간 대기
        yield return new WaitForSeconds(0.3f);

        // 피격 UI 비활성화
        hitEffect.SetActive(false);
    }
	
	참조 연결
	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임 상태 표시하기

레디 상태 > 2초 준비 > 고! > 0.5초 > 게임 시작

빈오브젝트 생성 > 위치값 초기화 > GameManager 로 변경

Canvas 에 UI > Legacy > Text > Text_GameState 로 설정
위치값 0,0,0
      450,100

텍스트 설정
폰트 스타일 Bold, 크기 70, 가운데 정렬


GameManager 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class GameManager : MonoBehaviour
{
    // 싱글톤 변수
    public static GameManager gm;

    private void Awake()
    {
        if (gm == null)
        {
            gm = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // 게임 상태 상수
    public enum GameState
    {
        Ready,
        Run,
        GameOver,
    }

    // 현재 게임 상태 변수
    public GameState gState;

    // 게임상태 UI 오브젝트 변수
    public GameObject gameLabel;
    // 게임 상태 UI 텍스트 컴포넌트 변수
    Text gameText;

    private void Start()
    {
        // 초기 게임 상태를 준비 상태로 설정
        gState = GameState.Ready;

        // 게임 상태 UI 오브젝트에서 Text 컴포넌트를 가져옴
        gameText = gameLabel.GetComponent<Text>();

        // 상태 텍스트의 내용을 'Ready...' 로 설정
        gameText.text = "Ready...";

        // 상태 텍스트의 색상을 주황색으로 설정
        gameText.color = new Color32(255, 185, 0, 255);

        // 게임 준비 -> 게임중으로 상태 전환
        StartCoroutine(ReadyToStart());
    }
    IEnumerator ReadyToStart()
    {
        // 2초간 대기
        yield return new WaitForSeconds(2f);

        // 상태 텍스트의 내용을 "Go!" 로 변경
        gameText.text = "Go!";

        //0.5초 대기
        yield return new WaitForSeconds(0.5f);

        // 상태 텍스트 비활성화
        gameLabel.SetActive(false);

        // 상태를 '게임중' 으로 변경
        gState = GameState.Run;
    }
}


GameManager 오브젝트 Game Label 에 참조 연결(Text_GameState)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임중 상태가 아닐시 조작 불가

CamRotate, PlayerRotate, PlayerFire, PlayerMove
 스크립트 의 Update() 메소드 최상단에
        
// 게임 상태가 '게임중' 상태 일 때만 조작할 수 있게 함
if (GameManager.gm.gState != GameManager.GameState.Run)
	return;
	
추가

////////////////////////////////////////////////////////////////////////////////////////////////////////////

게임 오버 구현

GameManager 스크립트 수정


변수 추가
    // PlayerMove 클래스 변수(player 라고 하면 보통 player 오브젝트를 뜻 하기에 다른이름이 좋다)
    PlayerMove player;


업데이트 메소드
    private void Update()
    {
        // 만일, 플레이어의 hp 가 0 이하라면
        if (player.hp <= 0)
        {
            // 상태 텍스트를 활성화
            gameLabel.SetActive(true);

            //상태 텍스트의 내용을 'GameOver' 로 설정
            gameText.text = "GameOver";

            // 상태 텍스트의 색상을 빨강으로 설정
            gameText.color = new Color32(255, 0, 0, 255);

            // 상태를 '게임 오버' 상태로 변경
            gState = GameState.GameOver;
        }
    }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

알파버전 시작

에셋 스토어에서 좀비 모델링 다운

Zombie 폴더 > FBX > Zombie1 > Model

Scale Factor : 모델의 스케일 값 적용하기전 크기 조정

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Enemy 오브젝트의 자식 오브젝트로 Zombie1 넣기

좀비 오브젝트의 피벗 위치가 발끝 으로 되어있음 좀비 오브젝트의 위치를 이동할 필요가 있음

좀비 오브젝트의 y값을 -1 로

좀비 오브젝트에 콜라이더를 맞추기 위해 Enemy 오브젝트의 콜라이더 수정

Enemy 오브젝트의 Character Controller 
센터값을 0, -0.1, 0
        0.25, 1.8
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

좀비 애니메이션 적용

프로젝트뷰 Animations 폴더 추가 > Animator Controller 생성 
> Zombie Anim 으로 이름 설정

애니메이터뷰 생성 > 새 스테이트(상태) 추가 > Idle 로 변경 
> Zombie 폴더 안의 Idle 애니메이션 적용(스테이트의 인스펙터뷰에 Motion 에 넣으면 됨)

새 스테이트 생성 > Move > Z_Run_Inplace 넣기

모션 자체에서 위치값이 바뀌는경우 Root Transform 체크 해제 하면 됨

Idle > Move 로 트랜지션 생성 > 파라메터 Trigger 생성 > idleToMove 로 설정