
프로토 타입 단계 부터 시작

씬 이름 변경 > MainScene

바닥 추가
3D 오브젝트 Plane 추가 > Ground 로 이름 변경
스케일 10, 1, 10

프로젝트뷰 Materials 폴더 추가 > 마테리얼 생성 Mat_Ground 로 변경 색 지정
Ground 에 넣기

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Capsule 오브젝트 추가 > Player 로 변경
위치값 0, 1, 0

MainCamera 오브젝트에 CamRotate 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamRotate : MonoBehaviour
{
    // 회전 속도 변수
    public float rotSpeed = 200f;

    float mX = 0f;
    float mY = 0f;

    private void Update()
    {
        // 마우스 입력을 받음
        float mouse_X = Input.GetAxis("Mouse X");
        float mouse_Y = Input.GetAxis("Mouse Y");

        // 회전값 변수에 마우스 입력값만큼 미리 누적
        mX += mouse_X * rotSpeed * Time.deltaTime;
        mY += mouse_Y * rotSpeed * Time.deltaTime;

        // 마우스 상하 이동 회전 변수(mY) 의 값을 -90 ~ 90 도 사이로 제한
        mY = Mathf.Clamp(mY, -90, 90);

        // 마우스 입력 값을 이용해 외전 방향을 결정(X축기준 회전 : 상하, Y축 기준 회전: 좌우)
        // 회전 방향으로 오브젝트 회전
        transform.eulerAngles = new Vector3(-mY, mX, 0);
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 회전 구현

Player 오브젝트에 PlayerRotate 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerRotate : MonoBehaviour
{
    // 회전 속도 변수
    public float rotSpeed = 200f;

    // 회전값 변수
    float mx = 0f;

    private void Update()
    {
        // 마우스 좌우 입력을 받음
        float mouse_X = Input.GetAxis("Mouse X");

        // 회전 값 변수에 마우스 입력 값만큼 미리 누적
        mx += mouse_X * rotSpeed * Time.deltaTime;

        // 회전 방향으로 물체를 회전기킴
        transform.eulerAngles = new Vector3(0, mx, 0);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

카메라 위치를 플레이어 와 동기화

Player 오브젝트에 자식 오브젝트로 빈오브젝트 CamPosition 생성
위치값 0, 0.25, 0

MainCamera 오브젝트에 CamFollow 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamFollow : MonoBehaviour
{
    // 목표가 될 트랜스폼 컴포넌트
    public Transform target;

    private void Update()
    {
        // 카메아의 위치를 목표 트랜스폼의 위치에 일치시킴
        transform.position = target.position;
    }
}

target 에 CamPosition 참조 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 움직임 구현

Player 오브젝트에 PlayerMove 스크립트 생성

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMove : MonoBehaviour
{
    public float moveSpeed = 7f;

    private void Update()
    {
        // 사용자의 입력을 받음
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        dir = dir.normalized;

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);

        // 이동 속도에 맞춰 이동
        transform.position += dir * moveSpeed * Time.deltaTime;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

중력 적용

위를 바라볼시 공중에 뜨는 문제 해결하기위해 중력 만들기

Player 오브젝트 선택 Character Controller 컴포넌트 추가

Character Controller 에는 이미 Collider 가 있기 때문에 
기존에 있던 Collider 컴포넌트 는 제거

PlayerMove 스크립트 열기

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMove : MonoBehaviour
{
    // 이동 속도 변수
    public float moveSpeed = 7f;

    // 캐릭터 컨트롤러 변수
    CharacterController cc;

    // 중력 변수
    float gravity = -20f;

    // 수직 속도 변수
    [SerializeField]
    float yVelocity = 0f;

    // 점프력 변수
    public float jumpPower = 10f;

    // 점프 상태 변수
    public bool isJumping = false;

    private void Start()
    {
        cc = GetComponent<CharacterController>();
    }

    private void Update()
    {
        // 사용자의 입력을 받음
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        // 이동 방향을 설정
        Vector3 dir = new Vector3(h, 0, v);
        dir = dir.normalized;

        // 메인 카메라를 기준으로 방향을 추가로 변환(Translate 말고 이방법도 있음)
        // 문제는 하늘을 바라보면 위로 떠버림
        dir = Camera.main.transform.TransformDirection(dir);

        // 점프 후 바닥에 닿은 상태인지 확인
        if (isJumping && cc.collisionFlags == CollisionFlags.Below)
        {
            // 점프 가능하게 변경
            isJumping = false;

            // 캐릭터의 수직속도를 0으로 만듬
            yVelocity = 0f;
        }

        // 만약 Spacebar 키를 입력했으면
        if (Input.GetButtonDown("Jump") && !isJumping)
        {
            // 캐릭터 수직 속도에 점프력 적용
            yVelocity = jumpPower;
            isJumping = true;
        }

        /* 이동 속도에 맞춰 이동 (캐릭터 컨트롤러로 이동함)
        transform.position += dir * moveSpeed * Time.deltaTime; */

        // 캐릭터 수직 속도에 중력 값을 적용
        yVelocity += gravity * Time.deltaTime;
        dir.y = yVelocity;

        // 이동속도에 맞춰 이동
        cc.Move(dir * moveSpeed * Time.deltaTime);
    }
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

수류탄 구현

3D 오브젝트 Sphere > Bomb 으로 변경 > 위치값 초기화

RigidBody 컴포넌트 추가

BombAction 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BombAction : MonoBehaviour
{
    public GameObject bombEffect;


    // 충돌시 처리
    private void OnCollisionEnter(Collision collision)
    {
        // 이펙트 프리팹 생성
        GameObject eff = Instantiate(bombEffect);

        // 이펙트의 위치는 자기 자신과 동일
        eff.transform.position = transform.position;

        // 자기자신 제거
        Destroy(gameObject);
    }
}

Bomb 을 프리팹으로 저장

/////////////////////////////////////////////////////////////////////////////////

에셋다운
에셋의 스크립트 폴더 제거

Exploson1 프리팹 의 스크립트 들 제거, 
자식오브젝트 의 Explosion - [Explosion6] 에 Simulation Speed 값을 2로 설정

프리팹의 부모 오브젝트에 DestroyEffect 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DestroyEffect : MonoBehaviour
{
    // 제거될 시간 변수
    public float destroyTime = 1.5f;

    //경과 시간 측정용 변수
    float currentTime = 0;

    private void Update()
    {
        // 만일 경과 시간이 제거될 시간을 초과하면 자기 자신을 제거
        if (currentTime > destroyTime)
        {
            Destroy(gameObject);
        }
        // 경과시간 누적
        currentTime += Time.deltaTime;
    }
}


위 코드 말고 Start() 에 Destroy(gameObject,1.5f); 해도 똑같음

////////////////////////////////////////////////////////////////////////////////////////////////////

Exploson1 프리팹 저장 후 오브젝트 로 끌어온 뒤 FX_Bomb 으로 이름 변경
자주 사용할 프리팹 폴더를 따로 만들고 그곳에 오리지날 프리팹으로 FX_Bomb 저장

///////////////////////////////////////////////////////////////////////////////////////////////////

BombAction 의 Bomb Effect 칸에 FX_Bomb 을 참조 연결

수류탄이 플레이어 와 닿아도 터지는 문제 를 없애기 위해 Layer 를 추가
각각 오브젝트에 맞는 레이어 추가후 Edit > Project Settings > Physics 에서 설정

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Player 오브젝트에 PlayerFire 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerFire : MonoBehaviour
{
    // 발사 위치
    public GameObject firePosition;

    // 투척 무기 오브젝트
    public GameObject bombFactory;

    // 투척 파워
    public float throwPower = 15f;

    // 피격 이펙트 오브젝트
    public GameObject bulletEffect;

    // 피격 이펙트 파티클 시스템
    ParticleSystem ps;

    private void Start()
    {
        // 피격 이펙트 오브젝트에서 파티클 시스템 컴포넌트 가져오기
        ps = bulletEffect.GetComponent<ParticleSystem>();
    }
    private void Update()
    {
        // 마우스 오른쪽 버튼을 입력 받음
        if (Input.GetMouseButtonDown(1))
        {
            // 수류탄 오브젝트를 생성한 후 수류탄의 생성 위치를 발사 위치로 변경
            GameObject bomb = Instantiate(bombFactory);
            bomb.transform.position = firePosition.transform.position;

            // 수류탄의 오브젝트의 Rigidbody 컴포넌트를 가져옴
            Rigidbody rb = bomb.GetComponent<Rigidbody>();

            // 카메라의 정면 방향으로 수류탄에 물리적인 힘을 가함 (Impulse : 순간적인 힘)
            rb.AddForce(Camera.main.transform.forward * throwPower, ForceMode.Impulse);
        }

        // 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 피격 이펙트의 위치를 레이가 부딪힌 지점으로 이동
                bulletEffect.transform.position = hitInfo.point;

                /* 피격 이펙트 의  forward 방향을 레이가
                 부딪힌 지점의 법선(부딫힌 면의 수직) 벡터와 일치 시킴 */
                bulletEffect.transform.forward = hitInfo.normal;

                // 피격 이펙트 플레이
                ps.Play();
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

다운 받은 에셋의 Effect > Stone_BulletEffect 프리팹 을 오브젝트로 생성
위치값 0, 1000, 0
스케일 2, 2, 2 로 설정

Player 오브젝트에 BulletEffect 에 참조 연결

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

다운받은 이미지 CrossHair 의 텍스쳐 타입을 Sprite(2D and UI) 로 설정

UI > Image > 이름을 CrossHair 
>위치 센터에 0,0,0
          30, 30

소스 이미지에 CrossHair 이미지 넣기

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

collider : 충돌대상의 가진 충돌체 컴포넌트
point : 충돌한 위치의 좌표
normal : 충돌한 지점의 법선벡터 ( 부딫힌 물체의 수직 벡터)
barycentricCoordinate : 충돌지점의 폴리곤 위치
distance : 레이 발사 지점부터 충돌한 지점까지 거리
.
.
.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

적 오브젝트 생성

3D 오브젝트 > Capsule > Enemy 로 변경

위치값 -20, 1, 0

적 구분되기 쉽게 마테리얼 추가

Enemy 오브젝트에 Character Controller 추가 > 콜라이더 제거

오브젝트 에 EnemyFSM 스크립트 추가

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyFSM : MonoBehaviour
{
    // 에너미 상태 상수
    enum EnemyState
    {
        Idle,
        Move,
        Attack,
        Return,
        Damaged,
        Die,
    }

    //에너미 상태 변수
    EnemyState m_State;

    // 플레이어 트랜스폼
    Transform player;

    // 캐릭터 컨트롤러 컴포넌트
    CharacterController cc;

    // 플레이어 발견 범위
    public float findDistance = 8f;
    // 공격 가능 범위
    public float attackDistance = 2f;
    // 공격 딜레이 시간
    float attackDelay = 2f;
    // 에너미 공격력
    public int attackPower = 3;
    // 누적 시간
    float currentTime = 0f;

    // 이동 속도
    public float moveSpeed = 5;

    // 초기 위치 저장
    Vector3 originPos;

    // 이동 가능 위치
    public float moveDistance = 20f;

    // 에너미 의 체력
    public int hp = 15;

    // 에너미의 최대 체력
    int maxHp = 15;

    private void Start()
    {
        // 최초의 에너미 상태를 대기 상태로
        m_State = EnemyState.Idle;

        /* 플레이어 의 트랜트폼 컴포넌트 받아오기
           (오브젝트가 게임 중간에 생성 되기에 미리 참조연결 할 수 없음)  */
        player = GameObject.Find("Player").transform;

        // 캐릭터 컴포넌트 불러오기
        cc = GetComponent<CharacterController>();

        // 자신의 초기 위치값 저장
        originPos = transform.position;
    }

    private void Update()
    {
        // 현재 상태 를 체크해 상태에 따라 메소드 호출
        CheckState();
    }

    void CheckState()
    {
        // 현재 상태 에 따라 메소드 호출
        switch (m_State)
        {
            case EnemyState.Idle:
                Idle();
                break;
            case EnemyState.Move:
                Move();
                break;
            case EnemyState.Attack:
                Attack();
                break;
            case EnemyState.Return:
                Return();
                break;
            case EnemyState.Damaged:
                // Damaged();
                break;
            case EnemyState.Die:
                // Die();
                break;

            default:
                break;
        }
    }

    void Idle()
    {
        // 만일, 플레이어 와 의 거리가 액션 범위 내라면 Move 로 전환
        if (Vector3.Distance(transform.position, player.position) <= findDistance)
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Idle -> Move");
        }
    }

    void Move()
    {
        // 만일, 현재 위치가 초기 위치에서 이동 가능 범위를 넘어간다면
        if (Vector3.Distance(transform.position, originPos) > moveDistance)
        {
            // 현재 상태를 복귀(Return) 으로 전환
            m_State = EnemyState.Return;
            print("상태 전환 : Move -> Return");
        }
        // 만일, 플레이어 와 의 거리가 공격 범위 밖 이라면 플레이어를 향해 이동
        else if (Vector3.Distance(transform.position, player.position) >= attackDistance)
        {
            // 이동 방향 설정
            Vector3 dir = (player.position - transform.position).normalized;

            // 캐릭터 컨트롤러 를 이용해 이동하기
            cc.Move(dir * moveSpeed * Time.deltaTime);
        }
        // 그렇지 않으면
        else
        {
            m_State = EnemyState.Attack;
            print("상태 전환 : Move -> Attack");

            //누적 시간을 공격 딜레이 시간만큼 미리 진행시켜 놓음
            currentTime = attackDelay;
        }
    }
    
    void Attack()
    {
        // 만일, 플레이어가 공격 범위 이내에 있다면 플레이어를 공격
        if (Vector3.Distance(transform.position, player.position)< attackDistance)
        {
            // 일정한 시간마다 플레이어를 공격
            currentTime += Time.deltaTime;
            if (currentTime > attackDelay)
            {
                player.GetComponent<PlayerMove>().DamageAction(attackPower);
                print("공격");
                currentTime = 0f;
            }
        }
        // 그렇지 않다면, 현재 상태를 이동으로 전환(재추격)
        else
        {
            m_State = EnemyState.Move;
            print("상태 전환 : Attack -> Move");
            currentTime = 0f;
        }
    }

    void Return()
    {
        // 만일, 초기 위치에서 거리가 0.1f 이상이라면 초기 위치 쪽으로 이동
        if (Vector3.Distance(transform.position, originPos) > 0.1f)
        {
            Vector3 dir = (originPos - transform.position).normalized;
            cc.Move(dir * moveSpeed * Time.deltaTime);
        }
        // 그렇지 않다면, 자신의 위치를 초기 위치로 조정하고 현재상태를 대기로 전환
        else
        {
            transform.position = originPos;

            // hp 를 다시 회복
            hp = maxHp;

            m_State = EnemyState.Idle;
            print("상태 전환 : Return -> Idle");
        }
    }

    void Damaged()
    {
        // 피격 상태를 처리하기 위한 코루틴 실행
        StartCoroutine(DamagedProcess());
    }

    // 데미지 처리용 코루틴 함수
    IEnumerator DamagedProcess()
    {
        // 피격 모션 시간만큼 기다림
        yield return new WaitForSeconds(0.5f);

        // 현재 상태를 이동 상태로 전환
        m_State = EnemyState.Move;
        print("상태 전환 : Damaged -> Move");
    }

    // 데미지 실행 함수
    public void HitEnemy(int hitPower)
    {
        // 만일, 이미 피격 상태 이거나 사망 상태 또는 복귀 상태라면
        // 아무 처리 하지않고 함수 종료
        if (m_State == EnemyState.Damaged || m_State == EnemyState.Die ||
            m_State == EnemyState.Return)
        {
            return;
        }

        // 플레이어의 공격력 만큼 에너미의 체력을 감소시킴
        hp -= hitPower;

        // 에너미의 체력이 0보다 크면 피격 상태로 전환
        if (hp > 0)
        {
            m_State = EnemyState.Damaged;
            print("상태 전환 : AnyState -> Damaged");
            Damaged();
        }
        // 그렇지 않다면 죽음 상태로 전환
        else
        {
            m_State = EnemyState.Die;
            print("상태 전환 : AnyState -> Die");
            //Die();
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////

적 피격시 체력 달게 만들기

PlayerFire 스크립트에 총알 발사 부분 수정

변수 추가

    // 발사 무기 공격력
    public int weaponPower = 5;

// 마우스 왼쪽 버튼을 입력
        if (Input.GetMouseButtonDown(0))
        {
            // 레이를 생성한 후 발사될 위치와 진행 방향을 설정
            Ray ray = new Ray(
                Camera.main.transform.position,
                Camera.main.transform.forward);

            // 레이가 부딯인 대상의 정보를 저장할 변수를 생성
            RaycastHit hitInfo;
            if (Physics.Raycast(ray,out hitInfo))
            {
                // 만일 레이에 부딪힌 대산의 레이어가 "Enemy" 라면 데미지 함수를 실행
                if (hitInfo.transform.gameObject.layer == LayerMask.NameToLayer("Enemy"))
                {
                    EnemyFSM eFsm = hitInfo.transform.GetComponent<EnemyFSM>();
                    eFsm.HitEnemy(weaponPower);
                }
                // 그렇지 않다면 레이에 부딪힌 지점에 피격 이펙트 플레이
                else
                {
                    // 피격 이펙트의 위치를 레이가 부딪힌 지점으로 이동
                    bulletEffect.transform.position = hitInfo.point;

                    /* 피격 이펙트 의  forward 방향을 레이가
                     부딪힌 지점의 법선(부딫힌 면의 수직) 벡터와 일치 시킴 */
                    bulletEffect.transform.forward = hitInfo.normal;

                    // 피격 이펙트 플레이
                    ps.Play();
                }
            }
        }


////////////////////////////////////////////////////////////////////////////////////////////////////////////

플레이어 피격시 데미지 입음

PlayerMove 스크립트에 변수 추가

    // 플레이어 체력
    public int hp = 20;
	
	
	메소드 추가
	
    // 플레이어의 피격 함수
    public void DamageAction(int damage)
    {
        hp -= damage;
    }